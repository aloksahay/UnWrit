(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_264a02._.js", {

"[project]/node_modules/multiformats/dist/src/bytes.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "coerce": (()=>coerce),
    "empty": (()=>empty),
    "equals": (()=>equals),
    "fromHex": (()=>fromHex),
    "fromString": (()=>fromString),
    "isBinary": (()=>isBinary),
    "toHex": (()=>toHex),
    "toString": (()=>toString)
});
const empty = new Uint8Array(0);
function toHex(d) {
    return d.reduce((hex, byte)=>hex + byte.toString(16).padStart(2, '0'), '');
}
function fromHex(hex) {
    const hexes = hex.match(/../g);
    return hexes != null ? new Uint8Array(hexes.map((b)=>parseInt(b, 16))) : empty;
}
function equals(aa, bb) {
    if (aa === bb) return true;
    if (aa.byteLength !== bb.byteLength) {
        return false;
    }
    for(let ii = 0; ii < aa.byteLength; ii++){
        if (aa[ii] !== bb[ii]) {
            return false;
        }
    }
    return true;
}
function coerce(o) {
    if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o;
    if (o instanceof ArrayBuffer) return new Uint8Array(o);
    if (ArrayBuffer.isView(o)) {
        return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error('Unknown type, must be binary type');
}
function isBinary(o) {
    return o instanceof ArrayBuffer || ArrayBuffer.isView(o);
}
function fromString(str) {
    return new TextEncoder().encode(str);
}
function toString(b) {
    return new TextDecoder().decode(b);
} //# sourceMappingURL=bytes.js.map
}}),
"[project]/node_modules/multiformats/dist/src/vendor/base-x.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/* eslint-disable */ // base-x encoding / decoding
// Copyright (c) 2018 base-x contributors
// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
// Distributed under the MIT software license, see the accompanying
// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
/**
 * @param {string} ALPHABET
 * @param {any} name
 */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
function base(ALPHABET, name) {
    if (ALPHABET.length >= 255) {
        throw new TypeError('Alphabet too long');
    }
    var BASE_MAP = new Uint8Array(256);
    for(var j = 0; j < BASE_MAP.length; j++){
        BASE_MAP[j] = 255;
    }
    for(var i = 0; i < ALPHABET.length; i++){
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
            throw new TypeError(x + ' is ambiguous');
        }
        BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up
    var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up
    /**
     * @param {any[] | Iterable<number>} source
     */ function encode(source) {
        // @ts-ignore
        if (source instanceof Uint8Array) ;
        else if (ArrayBuffer.isView(source)) {
            source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
            source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
            throw new TypeError('Expected Uint8Array');
        }
        if (source.length === 0) {
            return '';
        }
        // Skip & count leading zeroes.
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while(pbegin !== pend && source[pbegin] === 0){
            pbegin++;
            zeroes++;
        }
        // Allocate enough space in big-endian base58 representation.
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        // Process the bytes.
        while(pbegin !== pend){
            var carry = source[pbegin];
            // Apply "b58 = b58 * 256 + ch".
            var i = 0;
            for(var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++){
                carry += 256 * b58[it1] >>> 0;
                b58[it1] = carry % BASE >>> 0;
                carry = carry / BASE >>> 0;
            }
            if (carry !== 0) {
                throw new Error('Non-zero carry');
            }
            length = i;
            pbegin++;
        }
        // Skip leading zeroes in base58 result.
        var it2 = size - length;
        while(it2 !== size && b58[it2] === 0){
            it2++;
        }
        // Translate the result into a string.
        var str = LEADER.repeat(zeroes);
        for(; it2 < size; ++it2){
            str += ALPHABET.charAt(b58[it2]);
        }
        return str;
    }
    /**
     * @param {string | string[]} source
     */ function decodeUnsafe(source) {
        if (typeof source !== 'string') {
            throw new TypeError('Expected String');
        }
        if (source.length === 0) {
            return new Uint8Array();
        }
        var psz = 0;
        // Skip leading spaces.
        if (source[psz] === ' ') {
            return;
        }
        // Skip and count leading '1's.
        var zeroes = 0;
        var length = 0;
        while(source[psz] === LEADER){
            zeroes++;
            psz++;
        }
        // Allocate enough space in big-endian base256 representation.
        var size = (source.length - psz) * FACTOR + 1 >>> 0; // log(58) / log(256), rounded up.
        var b256 = new Uint8Array(size);
        // Process the characters.
        while(source[psz]){
            // Decode character
            var carry = BASE_MAP[source.charCodeAt(psz)];
            // Invalid character
            if (carry === 255) {
                return;
            }
            var i = 0;
            for(var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++){
                carry += BASE * b256[it3] >>> 0;
                b256[it3] = carry % 256 >>> 0;
                carry = carry / 256 >>> 0;
            }
            if (carry !== 0) {
                throw new Error('Non-zero carry');
            }
            length = i;
            psz++;
        }
        // Skip trailing spaces.
        if (source[psz] === ' ') {
            return;
        }
        // Skip leading zeroes in b256.
        var it4 = size - length;
        while(it4 !== size && b256[it4] === 0){
            it4++;
        }
        var vch = new Uint8Array(zeroes + (size - it4));
        var j = zeroes;
        while(it4 !== size){
            vch[j++] = b256[it4++];
        }
        return vch;
    }
    /**
     * @param {string | string[]} string
     */ function decode(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) {
            return buffer;
        }
        throw new Error(`Non-${name} character`);
    }
    return {
        encode: encode,
        decodeUnsafe: decodeUnsafe,
        decode: decode
    };
}
var src = base;
var _brrp__multiformats_scope_baseX = src;
const __TURBOPACK__default__export__ = _brrp__multiformats_scope_baseX;
 //# sourceMappingURL=base-x.js.map
}}),
"[project]/node_modules/multiformats/dist/src/bases/base.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Codec": (()=>Codec),
    "baseX": (()=>baseX),
    "from": (()=>from),
    "or": (()=>or),
    "rfc4648": (()=>rfc4648)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bytes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$vendor$2f$base$2d$x$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/vendor/base-x.js [app-client] (ecmascript)");
;
;
/**
 * Class represents both BaseEncoder and MultibaseEncoder meaning it
 * can be used to encode to multibase or base encode without multibase
 * prefix.
 */ class Encoder {
    name;
    prefix;
    baseEncode;
    constructor(name, prefix, baseEncode){
        this.name = name;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
    }
    encode(bytes) {
        if (bytes instanceof Uint8Array) {
            return `${this.prefix}${this.baseEncode(bytes)}`;
        } else {
            throw Error('Unknown type, must be binary type');
        }
    }
}
/**
 * Class represents both BaseDecoder and MultibaseDecoder so it could be used
 * to decode multibases (with matching prefix) or just base decode strings
 * with corresponding base encoding.
 */ class Decoder {
    name;
    prefix;
    baseDecode;
    prefixCodePoint;
    constructor(name, prefix, baseDecode){
        this.name = name;
        this.prefix = prefix;
        const prefixCodePoint = prefix.codePointAt(0);
        /* c8 ignore next 3 */ if (prefixCodePoint === undefined) {
            throw new Error('Invalid prefix character');
        }
        this.prefixCodePoint = prefixCodePoint;
        this.baseDecode = baseDecode;
    }
    decode(text) {
        if (typeof text === 'string') {
            if (text.codePointAt(0) !== this.prefixCodePoint) {
                throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
            }
            return this.baseDecode(text.slice(this.prefix.length));
        } else {
            throw Error('Can only multibase decode strings');
        }
    }
    or(decoder) {
        return or(this, decoder);
    }
}
class ComposedDecoder {
    decoders;
    constructor(decoders){
        this.decoders = decoders;
    }
    or(decoder) {
        return or(this, decoder);
    }
    decode(input) {
        const prefix = input[0];
        const decoder = this.decoders[prefix];
        if (decoder != null) {
            return decoder.decode(input);
        } else {
            throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
    }
}
function or(left, right) {
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    return new ComposedDecoder({
        ...left.decoders ?? {
            [left.prefix]: left
        },
        ...right.decoders ?? {
            [right.prefix]: right
        }
    });
}
class Codec {
    name;
    prefix;
    baseEncode;
    baseDecode;
    encoder;
    decoder;
    constructor(name, prefix, baseEncode, baseDecode){
        this.name = name;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder(name, prefix, baseEncode);
        this.decoder = new Decoder(name, prefix, baseDecode);
    }
    encode(input) {
        return this.encoder.encode(input);
    }
    decode(input) {
        return this.decoder.decode(input);
    }
}
function from({ name, prefix, encode, decode }) {
    return new Codec(name, prefix, encode, decode);
}
function baseX({ name, prefix, alphabet }) {
    const { encode, decode } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$vendor$2f$base$2d$x$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(alphabet, name);
    return from({
        prefix,
        name,
        encode,
        decode: (text)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coerce"])(decode(text))
    });
}
function decode(string, alphabet, bitsPerChar, name) {
    // Build the character lookup table:
    const codes = {};
    for(let i = 0; i < alphabet.length; ++i){
        codes[alphabet[i]] = i;
    }
    // Count the padding bytes:
    let end = string.length;
    while(string[end - 1] === '='){
        --end;
    }
    // Allocate the output:
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    // Parse the data:
    let bits = 0; // Number of bits currently in the buffer
    let buffer = 0; // Bits waiting to be written out, MSB first
    let written = 0; // Next byte to write
    for(let i = 0; i < end; ++i){
        // Read one character from the string:
        const value = codes[string[i]];
        if (value === undefined) {
            throw new SyntaxError(`Non-${name} character`);
        }
        // Append the bits to the buffer:
        buffer = buffer << bitsPerChar | value;
        bits += bitsPerChar;
        // Write out some bits if the buffer has a byte's worth:
        if (bits >= 8) {
            bits -= 8;
            out[written++] = 0xff & buffer >> bits;
        }
    }
    // Verify that we have received just enough bits:
    if (bits >= bitsPerChar || (0xff & buffer << 8 - bits) !== 0) {
        throw new SyntaxError('Unexpected end of data');
    }
    return out;
}
function encode(data, alphabet, bitsPerChar) {
    const pad = alphabet[alphabet.length - 1] === '=';
    const mask = (1 << bitsPerChar) - 1;
    let out = '';
    let bits = 0; // Number of bits currently in the buffer
    let buffer = 0; // Bits waiting to be written out, MSB first
    for(let i = 0; i < data.length; ++i){
        // Slurp data into the buffer:
        buffer = buffer << 8 | data[i];
        bits += 8;
        // Write out as much as we can:
        while(bits > bitsPerChar){
            bits -= bitsPerChar;
            out += alphabet[mask & buffer >> bits];
        }
    }
    // Partial character:
    if (bits !== 0) {
        out += alphabet[mask & buffer << bitsPerChar - bits];
    }
    // Add padding characters until we hit a byte boundary:
    if (pad) {
        while((out.length * bitsPerChar & 7) !== 0){
            out += '=';
        }
    }
    return out;
}
function rfc4648({ name, prefix, bitsPerChar, alphabet }) {
    return from({
        prefix,
        name,
        encode (input) {
            return encode(input, alphabet, bitsPerChar);
        },
        decode (input) {
            return decode(input, alphabet, bitsPerChar, name);
        }
    });
} //# sourceMappingURL=base.js.map
}}),
"[project]/node_modules/multiformats/dist/src/bases/base58.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "base58btc": (()=>base58btc),
    "base58flickr": (()=>base58flickr)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/base.js [app-client] (ecmascript)");
;
const base58btc = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["baseX"])({
    name: 'base58btc',
    prefix: 'z',
    alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
});
const base58flickr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["baseX"])({
    name: 'base58flickr',
    prefix: 'Z',
    alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'
}); //# sourceMappingURL=base58.js.map
}}),
"[project]/node_modules/multiformats/dist/src/bases/base32.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "base32": (()=>base32),
    "base32hex": (()=>base32hex),
    "base32hexpad": (()=>base32hexpad),
    "base32hexpadupper": (()=>base32hexpadupper),
    "base32hexupper": (()=>base32hexupper),
    "base32pad": (()=>base32pad),
    "base32padupper": (()=>base32padupper),
    "base32upper": (()=>base32upper),
    "base32z": (()=>base32z)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/base.js [app-client] (ecmascript)");
;
const base32 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'b',
    name: 'base32',
    alphabet: 'abcdefghijklmnopqrstuvwxyz234567',
    bitsPerChar: 5
});
const base32upper = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'B',
    name: 'base32upper',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',
    bitsPerChar: 5
});
const base32pad = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'c',
    name: 'base32pad',
    alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',
    bitsPerChar: 5
});
const base32padupper = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'C',
    name: 'base32padupper',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',
    bitsPerChar: 5
});
const base32hex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'v',
    name: 'base32hex',
    alphabet: '0123456789abcdefghijklmnopqrstuv',
    bitsPerChar: 5
});
const base32hexupper = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'V',
    name: 'base32hexupper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
    bitsPerChar: 5
});
const base32hexpad = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 't',
    name: 'base32hexpad',
    alphabet: '0123456789abcdefghijklmnopqrstuv=',
    bitsPerChar: 5
});
const base32hexpadupper = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'T',
    name: 'base32hexpadupper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',
    bitsPerChar: 5
});
const base32z = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'h',
    name: 'base32z',
    alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',
    bitsPerChar: 5
}); //# sourceMappingURL=base32.js.map
}}),
"[project]/node_modules/multiformats/dist/src/bases/base36.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "base36": (()=>base36),
    "base36upper": (()=>base36upper)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/base.js [app-client] (ecmascript)");
;
const base36 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["baseX"])({
    prefix: 'k',
    name: 'base36',
    alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'
});
const base36upper = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["baseX"])({
    prefix: 'K',
    name: 'base36upper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
}); //# sourceMappingURL=base36.js.map
}}),
"[project]/node_modules/multiformats/dist/src/vendor/varint.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/* eslint-disable */ __turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var encode_1 = encode;
var MSB = 0x80, REST = 0x7F, MSBALL = ~REST, INT = Math.pow(2, 31);
/**
 * @param {number} num
 * @param {number[]} out
 * @param {number} offset
 */ function encode(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while(num >= INT){
        out[offset++] = num & 0xFF | MSB;
        num /= 128;
    }
    while(num & MSBALL){
        out[offset++] = num & 0xFF | MSB;
        num >>>= 7;
    }
    out[offset] = num | 0;
    // @ts-ignore
    encode.bytes = offset - oldOffset + 1;
    return out;
}
var decode = read;
var MSB$1 = 0x80, REST$1 = 0x7F;
/**
 * @param {string | any[]} buf
 * @param {number} offset
 */ function read(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
        if (counter >= l) {
            // @ts-ignore
            read.bytes = 0;
            throw new RangeError('Could not decode varint');
        }
        b = buf[counter++];
        res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
        shift += 7;
    }while (b >= MSB$1)
    // @ts-ignore
    read.bytes = counter - offset;
    return res;
}
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = function(/** @type {number} */ value) {
    return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
var varint = {
    encode: encode_1,
    decode: decode,
    encodingLength: length
};
var _brrp_varint = varint;
const __TURBOPACK__default__export__ = _brrp_varint;
 //# sourceMappingURL=varint.js.map
}}),
"[project]/node_modules/multiformats/dist/src/varint.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "decode": (()=>decode),
    "encodeTo": (()=>encodeTo),
    "encodingLength": (()=>encodingLength)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$vendor$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/vendor/varint.js [app-client] (ecmascript)");
;
function decode(data, offset = 0) {
    const code = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$vendor$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].decode(data, offset);
    return [
        code,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$vendor$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].decode.bytes
    ];
}
function encodeTo(int, target, offset = 0) {
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$vendor$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].encode(int, target, offset);
    return target;
}
function encodingLength(int) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$vendor$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].encodingLength(int);
} //# sourceMappingURL=varint.js.map
}}),
"[project]/node_modules/multiformats/dist/src/hashes/digest.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Digest": (()=>Digest),
    "create": (()=>create),
    "decode": (()=>decode),
    "equals": (()=>equals),
    "hasCode": (()=>hasCode)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bytes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/varint.js [app-client] (ecmascript)");
;
;
function create(code, digest) {
    const size = digest.byteLength;
    const sizeOffset = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.encodingLength(code);
    const digestOffset = sizeOffset + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.encodingLength(size);
    const bytes = new Uint8Array(digestOffset + size);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.encodeTo(code, bytes, 0);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.encodeTo(size, bytes, sizeOffset);
    bytes.set(digest, digestOffset);
    return new Digest(code, size, digest, bytes);
}
function decode(multihash) {
    const bytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coerce"])(multihash);
    const [code, sizeOffset] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.decode(bytes);
    const [size, digestOffset] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.decode(bytes.subarray(sizeOffset));
    const digest = bytes.subarray(sizeOffset + digestOffset);
    if (digest.byteLength !== size) {
        throw new Error('Incorrect length');
    }
    return new Digest(code, size, digest, bytes);
}
function equals(a, b) {
    if (a === b) {
        return true;
    } else {
        const data = b;
        return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["equals"])(a.bytes, data.bytes);
    }
}
class Digest {
    code;
    size;
    digest;
    bytes;
    /**
     * Creates a multihash digest.
     */ constructor(code, size, digest, bytes){
        this.code = code;
        this.size = size;
        this.digest = digest;
        this.bytes = bytes;
    }
}
function hasCode(digest, code) {
    return digest.code === code;
} //# sourceMappingURL=digest.js.map
}}),
"[project]/node_modules/multiformats/dist/src/link/interface.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/* eslint-disable @typescript-eslint/no-unnecessary-type-constraint */ /* eslint-disable no-use-before-define */ __turbopack_esm__({});
;
 //# sourceMappingURL=interface.js.map
}}),
"[project]/node_modules/multiformats/dist/src/cid.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "CID": (()=>CID),
    "format": (()=>format),
    "fromJSON": (()=>fromJSON),
    "toJSON": (()=>toJSON)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/base58.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/base32.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/hashes/digest.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bytes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/varint.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base36$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/base36.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
function format(link, base) {
    const { bytes, version } = link;
    switch(version){
        case 0:
            return toStringV0(bytes, baseCache(link), base ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base58btc"].encoder);
        default:
            return toStringV1(bytes, baseCache(link), base ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base32"].encoder);
    }
}
function toJSON(link) {
    return {
        '/': format(link)
    };
}
function fromJSON(json) {
    return CID.parse(json['/']);
}
const cache = new WeakMap();
function baseCache(cid) {
    const baseCache = cache.get(cid);
    if (baseCache == null) {
        const baseCache = new Map();
        cache.set(cid, baseCache);
        return baseCache;
    }
    return baseCache;
}
class CID {
    code;
    version;
    multihash;
    bytes;
    '/';
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param multihash - (Multi)hash of the of the content.
     */ constructor(version, code, multihash, bytes){
        this.code = code;
        this.version = version;
        this.multihash = multihash;
        this.bytes = bytes;
        // flag to serializers that this is a CID and
        // should be treated specially
        this['/'] = bytes;
    }
    /**
     * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
     * please either use `CID.asCID(cid)` or switch to new signalling mechanism
     *
     * @deprecated
     */ get asCID() {
        return this;
    }
    // ArrayBufferView
    get byteOffset() {
        return this.bytes.byteOffset;
    }
    // ArrayBufferView
    get byteLength() {
        return this.bytes.byteLength;
    }
    toV0() {
        switch(this.version){
            case 0:
                {
                    return this;
                }
            case 1:
                {
                    const { code, multihash } = this;
                    if (code !== DAG_PB_CODE) {
                        throw new Error('Cannot convert a non dag-pb CID to CIDv0');
                    }
                    // sha2-256
                    if (multihash.code !== SHA_256_CODE) {
                        throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');
                    }
                    return CID.createV0(multihash);
                }
            default:
                {
                    throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
                }
        }
    }
    toV1() {
        switch(this.version){
            case 0:
                {
                    const { code, digest } = this.multihash;
                    const multihash = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.create(code, digest);
                    return CID.createV1(this.code, multihash);
                }
            case 1:
                {
                    return this;
                }
            default:
                {
                    throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
                }
        }
    }
    equals(other) {
        return CID.equals(this, other);
    }
    static equals(self, other) {
        const unknown = other;
        return unknown != null && self.code === unknown.code && self.version === unknown.version && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.equals(self.multihash, unknown.multihash);
    }
    toString(base) {
        return format(this, base);
    }
    toJSON() {
        return {
            '/': format(this)
        };
    }
    link() {
        return this;
    }
    [Symbol.toStringTag] = 'CID';
    // Legacy
    [Symbol.for('nodejs.util.inspect.custom')]() {
        return `CID(${this.toString()})`;
    }
    /**
     * Takes any input `value` and returns a `CID` instance if it was
     * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
     * it will return value back. If `value` is not instance of this CID
     * class, but is compatible CID it will return new instance of this
     * `CID` class. Otherwise returns null.
     *
     * This allows two different incompatible versions of CID library to
     * co-exist and interop as long as binary interface is compatible.
     */ static asCID(input) {
        if (input == null) {
            return null;
        }
        const value = input;
        if (value instanceof CID) {
            // If value is instance of CID then we're all set.
            return value;
        } else if (value['/'] != null && value['/'] === value.bytes || value.asCID === value) {
            // If value isn't instance of this CID class but `this.asCID === this` or
            // `value['/'] === value.bytes` is true it is CID instance coming from a
            // different implementation (diff version or duplicate). In that case we
            // rebase it to this `CID` implementation so caller is guaranteed to get
            // instance with expected API.
            const { version, code, multihash, bytes } = value;
            return new CID(version, code, multihash, bytes ?? encodeCID(version, code, multihash.bytes));
        } else if (value[cidSymbol] === true) {
            // If value is a CID from older implementation that used to be tagged via
            // symbol we still rebase it to the this `CID` implementation by
            // delegating that to a constructor.
            const { version, multihash, code } = value;
            const digest = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.decode(multihash);
            return CID.create(version, code, digest);
        } else {
            // Otherwise value is not a CID (or an incompatible version of it) in
            // which case we return `null`.
            return null;
        }
    }
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param digest - (Multi)hash of the of the content.
     */ static create(version, code, digest) {
        if (typeof code !== 'number') {
            throw new Error('String codecs are no longer supported');
        }
        if (!(digest.bytes instanceof Uint8Array)) {
            throw new Error('Invalid digest');
        }
        switch(version){
            case 0:
                {
                    if (code !== DAG_PB_CODE) {
                        throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
                    } else {
                        return new CID(version, code, digest, digest.bytes);
                    }
                }
            case 1:
                {
                    const bytes = encodeCID(version, code, digest.bytes);
                    return new CID(version, code, digest, bytes);
                }
            default:
                {
                    throw new Error('Invalid version');
                }
        }
    }
    /**
     * Simplified version of `create` for CIDv0.
     */ static createV0(digest) {
        return CID.create(0, DAG_PB_CODE, digest);
    }
    /**
     * Simplified version of `create` for CIDv1.
     *
     * @param code - Content encoding format code.
     * @param digest - Multihash of the content.
     */ static createV1(code, digest) {
        return CID.create(1, code, digest);
    }
    /**
     * Decoded a CID from its binary representation. The byte array must contain
     * only the CID with no additional bytes.
     *
     * An error will be thrown if the bytes provided do not contain a valid
     * binary representation of a CID.
     */ static decode(bytes) {
        const [cid, remainder] = CID.decodeFirst(bytes);
        if (remainder.length !== 0) {
            throw new Error('Incorrect length');
        }
        return cid;
    }
    /**
     * Decoded a CID from its binary representation at the beginning of a byte
     * array.
     *
     * Returns an array with the first element containing the CID and the second
     * element containing the remainder of the original byte array. The remainder
     * will be a zero-length byte array if the provided bytes only contained a
     * binary CID representation.
     */ static decodeFirst(bytes) {
        const specs = CID.inspectBytes(bytes);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coerce"])(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
        if (multihashBytes.byteLength !== specs.multihashSize) {
            throw new Error('Incorrect length');
        }
        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
        const digest = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
        const cid = specs.version === 0 ? CID.createV0(digest) : CID.createV1(specs.codec, digest);
        return [
            cid,
            bytes.subarray(specs.size)
        ];
    }
    /**
     * Inspect the initial bytes of a CID to determine its properties.
     *
     * Involves decoding up to 4 varints. Typically this will require only 4 to 6
     * bytes but for larger multicodec code values and larger multihash digest
     * lengths these varints can be quite large. It is recommended that at least
     * 10 bytes be made available in the `initialBytes` argument for a complete
     * inspection.
     */ static inspectBytes(initialBytes) {
        let offset = 0;
        const next = ()=>{
            const [i, length] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.decode(initialBytes.subarray(offset));
            offset += length;
            return i;
        };
        let version = next();
        let codec = DAG_PB_CODE;
        if (version === 18) {
            // CIDv0
            version = 0;
            offset = 0;
        } else {
            codec = next();
        }
        if (version !== 0 && version !== 1) {
            throw new RangeError(`Invalid CID version ${version}`);
        }
        const prefixSize = offset;
        const multihashCode = next(); // multihash code
        const digestSize = next(); // multihash length
        const size = offset + digestSize;
        const multihashSize = size - prefixSize;
        return {
            version,
            codec,
            multihashCode,
            digestSize,
            multihashSize,
            size
        };
    }
    /**
     * Takes cid in a string representation and creates an instance. If `base`
     * decoder is not provided will use a default from the configuration. It will
     * throw an error if encoding of the CID is not compatible with supplied (or
     * a default decoder).
     */ static parse(source, base) {
        const [prefix, bytes] = parseCIDtoBytes(source, base);
        const cid = CID.decode(bytes);
        if (cid.version === 0 && source[0] !== 'Q') {
            throw Error('Version 0 CID string must not include multibase prefix');
        }
        // Cache string representation to avoid computing it on `this.toString()`
        baseCache(cid).set(prefix, source);
        return cid;
    }
}
function parseCIDtoBytes(source, base) {
    switch(source[0]){
        // CIDv0 is parsed differently
        case 'Q':
            {
                const decoder = base ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base58btc"];
                return [
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base58btc"].prefix,
                    decoder.decode(`${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base58btc"].prefix}${source}`)
                ];
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base58btc"].prefix:
            {
                const decoder = base ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base58btc"];
                return [
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base58btc"].prefix,
                    decoder.decode(source)
                ];
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base32"].prefix:
            {
                const decoder = base ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base32"];
                return [
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base32"].prefix,
                    decoder.decode(source)
                ];
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base36$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base36"].prefix:
            {
                const decoder = base ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base36$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base36"];
                return [
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base36$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base36"].prefix,
                    decoder.decode(source)
                ];
            }
        default:
            {
                if (base == null) {
                    throw Error('To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided');
                }
                return [
                    source[0],
                    base.decode(source)
                ];
            }
    }
}
function toStringV0(bytes, cache, base) {
    const { prefix } = base;
    if (prefix !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base58btc"].prefix) {
        throw Error(`Cannot string encode V0 in ${base.name} encoding`);
    }
    const cid = cache.get(prefix);
    if (cid == null) {
        const cid = base.encode(bytes).slice(1);
        cache.set(prefix, cid);
        return cid;
    } else {
        return cid;
    }
}
function toStringV1(bytes, cache, base) {
    const { prefix } = base;
    const cid = cache.get(prefix);
    if (cid == null) {
        const cid = base.encode(bytes);
        cache.set(prefix, cid);
        return cid;
    } else {
        return cid;
    }
}
const DAG_PB_CODE = 0x70;
const SHA_256_CODE = 0x12;
function encodeCID(version, code, multihash) {
    const codeOffset = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.encodingLength(version);
    const hashOffset = codeOffset + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.encodingLength(code);
    const bytes = new Uint8Array(hashOffset + multihash.byteLength);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.encodeTo(version, bytes, 0);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.encodeTo(code, bytes, codeOffset);
    bytes.set(multihash, hashOffset);
    return bytes;
}
const cidSymbol = Symbol.for('@ipld/js-cid/CID'); //# sourceMappingURL=cid.js.map
}}),
"[project]/node_modules/multiformats/dist/src/cid.js [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/base32.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base36$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/base36.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/base58.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bytes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/hashes/digest.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/varint.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2f$interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/link/interface.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/cid.js [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/uint8arrays/dist/src/equals.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * Returns true if the two passed Uint8Arrays have the same content
 */ __turbopack_esm__({
    "equals": (()=>equals)
});
function equals(a, b) {
    if (a === b) {
        return true;
    }
    if (a.byteLength !== b.byteLength) {
        return false;
    }
    for(let i = 0; i < a.byteLength; i++){
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
} //# sourceMappingURL=equals.js.map
}}),
"[project]/node_modules/multiformats/dist/src/bases/base10.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "base10": (()=>base10)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/base.js [app-client] (ecmascript)");
;
const base10 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["baseX"])({
    prefix: '9',
    name: 'base10',
    alphabet: '0123456789'
}); //# sourceMappingURL=base10.js.map
}}),
"[project]/node_modules/multiformats/dist/src/bases/base16.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "base16": (()=>base16),
    "base16upper": (()=>base16upper)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/base.js [app-client] (ecmascript)");
;
const base16 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'f',
    name: 'base16',
    alphabet: '0123456789abcdef',
    bitsPerChar: 4
});
const base16upper = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'F',
    name: 'base16upper',
    alphabet: '0123456789ABCDEF',
    bitsPerChar: 4
}); //# sourceMappingURL=base16.js.map
}}),
"[project]/node_modules/multiformats/dist/src/bases/base2.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "base2": (()=>base2)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/base.js [app-client] (ecmascript)");
;
const base2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: '0',
    name: 'base2',
    alphabet: '01',
    bitsPerChar: 1
}); //# sourceMappingURL=base2.js.map
}}),
"[project]/node_modules/multiformats/dist/src/bases/base256emoji.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "base256emoji": (()=>base256emoji)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/base.js [app-client] (ecmascript)");
;
const alphabet = Array.from('');
const alphabetBytesToChars = alphabet.reduce((p, c, i)=>{
    p[i] = c;
    return p;
}, []);
const alphabetCharsToBytes = alphabet.reduce((p, c, i)=>{
    const codePoint = c.codePointAt(0);
    if (codePoint == null) {
        throw new Error(`Invalid character: ${c}`);
    }
    p[codePoint] = i;
    return p;
}, []);
function encode(data) {
    return data.reduce((p, c)=>{
        p += alphabetBytesToChars[c];
        return p;
    }, '');
}
function decode(str) {
    const byts = [];
    for (const char of str){
        const codePoint = char.codePointAt(0);
        if (codePoint == null) {
            throw new Error(`Invalid character: ${char}`);
        }
        const byt = alphabetCharsToBytes[codePoint];
        if (byt == null) {
            throw new Error(`Non-base256emoji character: ${char}`);
        }
        byts.push(byt);
    }
    return new Uint8Array(byts);
}
const base256emoji = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["from"])({
    prefix: '',
    name: 'base256emoji',
    encode,
    decode
}); //# sourceMappingURL=base256emoji.js.map
}}),
"[project]/node_modules/multiformats/dist/src/bases/base64.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "base64": (()=>base64),
    "base64pad": (()=>base64pad),
    "base64url": (()=>base64url),
    "base64urlpad": (()=>base64urlpad)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/base.js [app-client] (ecmascript)");
;
const base64 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'm',
    name: 'base64',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
    bitsPerChar: 6
});
const base64pad = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'M',
    name: 'base64pad',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
    bitsPerChar: 6
});
const base64url = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'u',
    name: 'base64url',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
    bitsPerChar: 6
});
const base64urlpad = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'U',
    name: 'base64urlpad',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',
    bitsPerChar: 6
}); //# sourceMappingURL=base64.js.map
}}),
"[project]/node_modules/multiformats/dist/src/bases/base8.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "base8": (()=>base8)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/base.js [app-client] (ecmascript)");
;
const base8 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: '7',
    name: 'base8',
    alphabet: '01234567',
    bitsPerChar: 3
}); //# sourceMappingURL=base8.js.map
}}),
"[project]/node_modules/multiformats/dist/src/bases/identity.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "identity": (()=>identity)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bytes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/base.js [app-client] (ecmascript)");
;
;
const identity = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["from"])({
    prefix: '\x00',
    name: 'identity',
    encode: (buf)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toString"])(buf),
    decode: (str)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromString"])(str)
}); //# sourceMappingURL=identity.js.map
}}),
"[project]/node_modules/multiformats/dist/src/codecs/json.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "code": (()=>code),
    "decode": (()=>decode),
    "encode": (()=>encode),
    "name": (()=>name)
});
const textEncoder = new TextEncoder();
const textDecoder = new TextDecoder();
const name = 'json';
const code = 0x0200;
function encode(node) {
    return textEncoder.encode(JSON.stringify(node));
}
function decode(data) {
    return JSON.parse(textDecoder.decode(data));
} //# sourceMappingURL=json.js.map
}}),
"[project]/node_modules/multiformats/dist/src/codecs/raw.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "code": (()=>code),
    "decode": (()=>decode),
    "encode": (()=>encode),
    "name": (()=>name)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bytes.js [app-client] (ecmascript)");
;
const name = 'raw';
const code = 0x55;
function encode(node) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coerce"])(node);
}
function decode(data) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coerce"])(data);
} //# sourceMappingURL=raw.js.map
}}),
"[project]/node_modules/multiformats/dist/src/hashes/identity.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "identity": (()=>identity)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bytes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/hashes/digest.js [app-client] (ecmascript)");
;
;
const code = 0x0;
const name = 'identity';
const encode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coerce"];
function digest(input) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.create(code, encode(input));
}
const identity = {
    code,
    name,
    encode,
    digest
}; //# sourceMappingURL=identity.js.map
}}),
"[project]/node_modules/multiformats/dist/src/hashes/hasher.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Hasher": (()=>Hasher),
    "from": (()=>from)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/hashes/digest.js [app-client] (ecmascript)");
;
function from({ name, code, encode }) {
    return new Hasher(name, code, encode);
}
class Hasher {
    name;
    code;
    encode;
    constructor(name, code, encode){
        this.name = name;
        this.code = code;
        this.encode = encode;
    }
    digest(input) {
        if (input instanceof Uint8Array) {
            const result = this.encode(input);
            return result instanceof Uint8Array ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.create(this.code, result) : result.then((digest)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.create(this.code, digest));
        } else {
            throw Error('Unknown type, must be binary type');
        /* c8 ignore next 1 */ }
    }
} //# sourceMappingURL=hasher.js.map
}}),
"[project]/node_modules/multiformats/dist/src/hashes/sha2-browser.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/* global crypto */ __turbopack_esm__({
    "sha256": (()=>sha256),
    "sha512": (()=>sha512)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$hasher$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/hashes/hasher.js [app-client] (ecmascript)");
;
function sha(name) {
    return async (data)=>new Uint8Array(await crypto.subtle.digest(name, data));
}
const sha256 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$hasher$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["from"])({
    name: 'sha2-256',
    code: 0x12,
    encode: sha('SHA-256')
});
const sha512 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$hasher$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["from"])({
    name: 'sha2-512',
    code: 0x13,
    encode: sha('SHA-512')
}); //# sourceMappingURL=sha2-browser.js.map
}}),
"[project]/node_modules/multiformats/dist/src/bases/interface.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// Base encoders / decoders just base encode / decode between binary and
// textual representation. They are unaware of multibase.
__turbopack_esm__({});
;
 //# sourceMappingURL=interface.js.map
}}),
"[project]/node_modules/multiformats/dist/src/hashes/interface.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// # Multihash
__turbopack_esm__({});
;
 //# sourceMappingURL=interface.js.map
}}),
"[project]/node_modules/multiformats/dist/src/codecs/interface.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({});
;
 //# sourceMappingURL=interface.js.map
}}),
"[project]/node_modules/multiformats/dist/src/block/interface.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({});
;
 //# sourceMappingURL=interface.js.map
}}),
"[project]/node_modules/multiformats/dist/src/interface.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({});
;
;
;
;
;
 //# sourceMappingURL=interface.js.map
}}),
"[project]/node_modules/multiformats/dist/src/interface.js [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/interface.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/hashes/interface.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$codecs$2f$interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/codecs/interface.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2f$interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/link/interface.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$block$2f$interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/block/interface.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/interface.js [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/multiformats/dist/src/index.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @packageDocumentation
 *
 * This library defines common interfaces and low level building blocks for various interrelated multiformat technologies (multicodec, multihash, multibase, and CID). They can be used to implement custom base encoders / decoders / codecs, codec encoders /decoders and multihash hashers that comply to the interface that layers above assume.
 *
 * This library provides implementations for most basics and many others can be found in linked repositories.
 *
 * ```TypeScript
 * import { CID } from 'multiformats/cid'
 * import * as json from 'multiformats/codecs/json'
 * import { sha256 } from 'multiformats/hashes/sha2'
 *
 * const bytes = json.encode({ hello: 'world' })
 *
 * const hash = await sha256.digest(bytes)
 * const cid = CID.create(1, json.code, hash)
 * //> CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)
 * ```
 *
 * ## Creating Blocks
 *
 * ```TypeScript
 * import * as Block from 'multiformats/block'
 * import * as codec from '@ipld/dag-cbor'
 * import { sha256 as hasher } from 'multiformats/hashes/sha2'
 *
 * const value = { hello: 'world' }
 *
 * // encode a block
 * let block = await Block.encode({ value, codec, hasher })
 *
 * block.value // { hello: 'world' }
 * block.bytes // Uint8Array
 * block.cid   // CID() w/ sha2-256 hash address and dag-cbor codec
 *
 * // you can also decode blocks from their binary state
 * block = await Block.decode({ bytes: block.bytes, codec, hasher })
 *
 * // if you have the cid you can also verify the hash on decode
 * block = await Block.create({ bytes: block.bytes, cid: block.cid, codec, hasher })
 * ```
 *
 * ## Multibase Encoders / Decoders / Codecs
 *
 * CIDs can be serialized to string representation using multibase encoders that implement [`MultibaseEncoder`](https://github.com/multiformats/js-multiformats/blob/master/src/bases/interface.ts) interface. This library provides quite a few implementations that can be imported:
 *
 * ```TypeScript
 * import { base64 } from "multiformats/bases/base64"
 * cid.toString(base64.encoder)
 * //> 'mAYAEEiCTojlxqRTl6svwqNJRVM2jCcPBxy+7mRTUfGDzy2gViA'
 * ```
 *
 * Parsing CID string serialized CIDs requires multibase decoder that implements [`MultibaseDecoder`](https://github.com/multiformats/js-multiformats/blob/master/src/bases/interface.ts) interface. This library provides a decoder for every encoder it provides:
 *
 * ```TypeScript
 * CID.parse('mAYAEEiCTojlxqRTl6svwqNJRVM2jCcPBxy+7mRTUfGDzy2gViA', base64.decoder)
 * //> CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)
 * ```
 *
 * Dual of multibase encoder & decoder is defined as multibase codec and it exposes
 * them as `encoder` and `decoder` properties. For added convenience codecs also
 * implement `MultibaseEncoder` and `MultibaseDecoder` interfaces so they could be
 * used as either or both:
 *
 * ```TypeScript
 * cid.toString(base64)
 * CID.parse(cid.toString(base64), base64)
 * ```
 *
 * **Note:** CID implementation comes bundled with `base32` and `base58btc`
 * multibase codecs so that CIDs can be base serialized to (version specific)
 * default base encoding and parsed without having to supply base encoders/decoders:
 *
 * ```TypeScript
 * const v1 = CID.parse('bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea')
 * v1.toString()
 * //> 'bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea'
 *
 * const v0 = CID.parse('QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n')
 * v0.toString()
 * //> 'QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n'
 * v0.toV1().toString()
 * //> 'bafybeihdwdcefgh4dqkjv67uzcmw7ojee6xedzdetojuzjevtenxquvyku'
 * ```
 *
 * ## Multicodec Encoders / Decoders / Codecs
 *
 * This library defines [`BlockEncoder`, `BlockDecoder` and `BlockCodec` interfaces](https://github.com/multiformats/js-multiformats/blob/master/src/codecs/interface.ts).
 * Codec implementations should conform to the `BlockCodec` interface which implements both `BlockEncoder` and `BlockDecoder`.
 * Here is an example implementation of JSON `BlockCodec`.
 *
 * ```TypeScript
 * export const { name, code, encode, decode } = {
 *   name: 'json',
 *   code: 0x0200,
 *   encode: json => new TextEncoder().encode(JSON.stringify(json)),
 *   decode: bytes => JSON.parse(new TextDecoder().decode(bytes))
 * }
 * ```
 *
 * ## Multihash Hashers
 *
 * This library defines [`MultihashHasher` and `MultihashDigest` interfaces](https://github.com/multiformats/js-multiformats/blob/master/src/hashes/interface.ts) and convinient function for implementing them:
 *
 * ```TypeScript
 * import * as hasher from 'multiformats/hashes/hasher'
 *
 * const sha256 = hasher.from({
 *   // As per multiformats table
 *   // https://github.com/multiformats/multicodec/blob/master/table.csv#L9
 *   name: 'sha2-256',
 *   code: 0x12,
 *
 *   encode: (input) => new Uint8Array(crypto.createHash('sha256').update(input).digest())
 * })
 *
 * const hash = await sha256.digest(json.encode({ hello: 'world' }))
 * CID.create(1, json.code, hash)
 *
 * //> CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)
 * ```
 *
 * ## Traversal
 *
 * This library contains higher-order functions for traversing graphs of data easily.
 *
 * `walk()` walks through the links in each block of a DAG calling a user-supplied loader function for each one, in depth-first order with no duplicate block visits. The loader should return a `Block` object and can be used to inspect and collect block ordering for a full DAG walk. The loader should `throw` on error, and return `null` if a block should be skipped by `walk()`.
 *
 * ```TypeScript
 * import { walk } from 'multiformats/traversal'
 * import * as Block from 'multiformats/block'
 * import * as codec from 'multiformats/codecs/json'
 * import { sha256 as hasher } from 'multiformats/hashes/sha2'
 *
 * // build a DAG (a single block for this simple example)
 * const value = { hello: 'world' }
 * const block = await Block.encode({ value, codec, hasher })
 * const { cid } = block
 * console.log(cid)
 * //> CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)
 *
 * // create a loader function that also collects CIDs of blocks in
 * // their traversal order
 * const load = (cid, blocks) => async (cid) => {
 *   // fetch a block using its cid
 *   // e.g.: const block = await fetchBlockByCID(cid)
 *   blocks.push(cid)
 *   return block
 * }
 *
 * // collect blocks in this DAG starting from the root `cid`
 * const blocks = []
 * await walk({ cid, load: load(cid, blocks) })
 *
 * console.log(blocks)
 * //> [CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)]
 * ```
 *
 * ## Legacy interface
 *
 * [`blockcodec-to-ipld-format`](https://github.com/ipld/js-blockcodec-to-ipld-format) converts a multiformats [`BlockCodec`](https://github.com/multiformats/js-multiformats/blob/master/src/codecs/interface.ts#L21) into an
 * [`interface-ipld-format`](https://github.com/ipld/interface-ipld-format) for use with the [`ipld`](https://github.com/ipld/ipld) package. This can help bridge IPLD codecs implemented using the structure and interfaces defined here to existing code that assumes, or requires `interface-ipld-format`. This bridge also includes the relevant TypeScript definitions.
 *
 * ## Implementations
 *
 * By default, no base encodings (other than base32 & base58btc), hash functions,
 * or codec implementations are exposed by `multiformats`, you need to
 * import the ones you need yourself.
 *
 * ### Multibase codecs
 *
 * | bases                                                         | import                      | repo                                                                                              |
 * | ------------------------------------------------------------- | --------------------------- | ------------------------------------------------------------------------------------------------- |
 * | `base16`                                                      | `multiformats/bases/base16` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) |
 * | `base32`, `base32pad`, `base32hex`, `base32hexpad`, `base32z` | `multiformats/bases/base32` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) |
 * | `base64`, `base64pad`, `base64url`, `base64urlpad`            | `multiformats/bases/base64` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) |
 * | `base58btc`, `base58flick4`                                   | `multiformats/bases/base58` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) |
 *
 * Other (less useful) bases implemented in [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) include: `base2`, `base8`, `base10`, `base36` and `base256emoji`.
 *
 * ### Multihash hashers
 *
 * | hashes                                                                                                                          | import                         | repo                                                                                                               |
 * | ------------------------------------------------------------------------------------------------------------------------------- | ------------------------------ | ------------------------------------------------------------------------------------------------------------------ |
 * | `sha2-256`, `sha2-512`                                                                                                          | `multiformats/hashes/sha2`     | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/src/hashes)             |
 * | `sha3-224`, `sha3-256`, `sha3-384`,`sha3-512`, `shake-128`, `shake-256`, `keccak-224`, `keccak-256`, `keccak-384`, `keccak-512` | `@multiformats/sha3`           | [multiformats/js-sha3](https://github.com/multiformats/js-sha3)                                                    |
 * | `identity`                                                                                                                      | `multiformats/hashes/identity` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/src/hashes/identity.js) |
 * | `murmur3-128`, `murmur3-32`                                                                                                     | `@multiformats/murmur3`        | [multiformats/js-murmur3](https://github.com/multiformats/js-murmur3)                                              |
 * | `blake2b-*`, `blake2s-*`                                                                                                        | `@multiformats/blake2`         | [multiformats/js-blake2](https://github.com/multiformats/js-blake2)                                                |
 *
 * ### IPLD codecs (multicodec)
 *
 * | codec      | import                     | repo                                                                                                   |
 * | ---------- | -------------------------- | ------------------------------------------------------------------------------------------------------ |
 * | `raw`      | `multiformats/codecs/raw`  | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/src/codecs) |
 * | `json`     | `multiformats/codecs/json` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/src/codecs) |
 * | `dag-cbor` | `@ipld/dag-cbor`           | [ipld/js-dag-cbor](https://github.com/ipld/js-dag-cbor)                                                |
 * | `dag-json` | `@ipld/dag-json`           | [ipld/js-dag-json](https://github.com/ipld/js-dag-json)                                                |
 * | `dag-pb`   | `@ipld/dag-pb`             | [ipld/js-dag-pb](https://github.com/ipld/js-dag-pb)                                                    |
 * | `dag-jose` | `dag-jose`                 | [ceramicnetwork/js-dag-jose](https://github.com/ceramicnetwork/js-dag-jose)                            |
 */ __turbopack_esm__({});
;
;
;
;
;
;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/multiformats/dist/src/index.js [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bytes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/cid.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/hashes/digest.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$hasher$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/hashes/hasher.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/varint.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/interface.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/index.js [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/multiformats/dist/src/basics.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "bases": (()=>bases),
    "codecs": (()=>codecs),
    "hashes": (()=>hashes)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$identity$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/identity.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/base2.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/base8.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base10$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/base10.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base16$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/base16.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/base32.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base36$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/base36.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/base58.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/base64.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base256emoji$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/base256emoji.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$sha2$2d$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/hashes/sha2-browser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$identity$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/hashes/identity.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$codecs$2f$raw$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/codecs/raw.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$codecs$2f$json$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/codecs/json.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
const bases = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$identity$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base10$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base16$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base36$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base256emoji$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__
};
const hashes = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$sha2$2d$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$identity$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__
};
const codecs = {
    raw: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$codecs$2f$raw$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    json: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$codecs$2f$json$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__
};
;
 //# sourceMappingURL=basics.js.map
}}),
"[project]/node_modules/multiformats/dist/src/basics.js [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base10$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/base10.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base16$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/base16.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/base2.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base256emoji$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/base256emoji.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/base32.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base36$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/base36.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/base58.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/base64.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/base8.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$identity$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/identity.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$codecs$2f$json$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/codecs/json.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$codecs$2f$raw$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/codecs/raw.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$identity$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/hashes/identity.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$sha2$2d$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/hashes/sha2-browser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$basics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/basics.js [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/uint8arrays/dist/src/alloc.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * Returns a `Uint8Array` of the requested size. Referenced memory will
 * be initialized to 0.
 */ __turbopack_esm__({
    "alloc": (()=>alloc),
    "allocUnsafe": (()=>allocUnsafe)
});
function alloc(size = 0) {
    return new Uint8Array(size);
}
function allocUnsafe(size = 0) {
    return new Uint8Array(size);
} //# sourceMappingURL=alloc.js.map
}}),
"[project]/node_modules/uint8arrays/dist/src/util/bases.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$basics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/basics.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/uint8arrays/dist/src/alloc.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$basics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/basics.js [app-client] (ecmascript) <locals>");
;
;
function createCodec(name, prefix, encode, decode) {
    return {
        name,
        prefix,
        encoder: {
            name,
            prefix,
            encode
        },
        decoder: {
            decode
        }
    };
}
const string = createCodec('utf8', 'u', (buf)=>{
    const decoder = new TextDecoder('utf8');
    return 'u' + decoder.decode(buf);
}, (str)=>{
    const encoder = new TextEncoder();
    return encoder.encode(str.substring(1));
});
const ascii = createCodec('ascii', 'a', (buf)=>{
    let string = 'a';
    for(let i = 0; i < buf.length; i++){
        string += String.fromCharCode(buf[i]);
    }
    return string;
}, (str)=>{
    str = str.substring(1);
    const buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["allocUnsafe"])(str.length);
    for(let i = 0; i < str.length; i++){
        buf[i] = str.charCodeAt(i);
    }
    return buf;
});
const BASES = {
    utf8: string,
    'utf-8': string,
    hex: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$basics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bases"].base16,
    latin1: ascii,
    ascii,
    binary: ascii,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$basics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bases"]
};
const __TURBOPACK__default__export__ = BASES;
 //# sourceMappingURL=bases.js.map
}}),
"[project]/node_modules/uint8arrays/dist/src/to-string.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "toString": (()=>toString)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$bases$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/uint8arrays/dist/src/util/bases.js [app-client] (ecmascript)");
;
function toString(array, encoding = 'utf8') {
    const base = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$bases$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"][encoding];
    if (base == null) {
        throw new Error(`Unsupported encoding "${encoding}"`);
    }
    // strip multibase prefix
    return base.encoder.encode(array).substring(1);
} //# sourceMappingURL=to-string.js.map
}}),
"[project]/node_modules/uint8-varint/dist/src/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/* eslint-disable no-fallthrough */ __turbopack_esm__({
    "decode": (()=>decode),
    "decodeUint8Array": (()=>decodeUint8Array),
    "decodeUint8ArrayList": (()=>decodeUint8ArrayList),
    "encode": (()=>encode),
    "encodeUint8Array": (()=>encodeUint8Array),
    "encodeUint8ArrayList": (()=>encodeUint8ArrayList),
    "encodingLength": (()=>encodingLength)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/uint8arrays/dist/src/alloc.js [app-client] (ecmascript)");
;
const N1 = Math.pow(2, 7);
const N2 = Math.pow(2, 14);
const N3 = Math.pow(2, 21);
const N4 = Math.pow(2, 28);
const N5 = Math.pow(2, 35);
const N6 = Math.pow(2, 42);
const N7 = Math.pow(2, 49);
/** Most significant bit of a byte */ const MSB = 0x80;
/** Rest of the bits in a byte */ const REST = 0x7f;
function encodingLength(value) {
    if (value < N1) {
        return 1;
    }
    if (value < N2) {
        return 2;
    }
    if (value < N3) {
        return 3;
    }
    if (value < N4) {
        return 4;
    }
    if (value < N5) {
        return 5;
    }
    if (value < N6) {
        return 6;
    }
    if (value < N7) {
        return 7;
    }
    if (Number.MAX_SAFE_INTEGER != null && value > Number.MAX_SAFE_INTEGER) {
        throw new RangeError('Could not encode varint');
    }
    return 8;
}
function encodeUint8Array(value, buf, offset = 0) {
    switch(encodingLength(value)){
        case 8:
            {
                buf[offset++] = value & 0xFF | MSB;
                value /= 128;
            }
        case 7:
            {
                buf[offset++] = value & 0xFF | MSB;
                value /= 128;
            }
        case 6:
            {
                buf[offset++] = value & 0xFF | MSB;
                value /= 128;
            }
        case 5:
            {
                buf[offset++] = value & 0xFF | MSB;
                value /= 128;
            }
        case 4:
            {
                buf[offset++] = value & 0xFF | MSB;
                value >>>= 7;
            }
        case 3:
            {
                buf[offset++] = value & 0xFF | MSB;
                value >>>= 7;
            }
        case 2:
            {
                buf[offset++] = value & 0xFF | MSB;
                value >>>= 7;
            }
        case 1:
            {
                buf[offset++] = value & 0xFF;
                value >>>= 7;
                break;
            }
        default:
            throw new Error('unreachable');
    }
    return buf;
}
function encodeUint8ArrayList(value, buf, offset = 0) {
    switch(encodingLength(value)){
        case 8:
            {
                buf.set(offset++, value & 0xFF | MSB);
                value /= 128;
            }
        case 7:
            {
                buf.set(offset++, value & 0xFF | MSB);
                value /= 128;
            }
        case 6:
            {
                buf.set(offset++, value & 0xFF | MSB);
                value /= 128;
            }
        case 5:
            {
                buf.set(offset++, value & 0xFF | MSB);
                value /= 128;
            }
        case 4:
            {
                buf.set(offset++, value & 0xFF | MSB);
                value >>>= 7;
            }
        case 3:
            {
                buf.set(offset++, value & 0xFF | MSB);
                value >>>= 7;
            }
        case 2:
            {
                buf.set(offset++, value & 0xFF | MSB);
                value >>>= 7;
            }
        case 1:
            {
                buf.set(offset++, value & 0xFF);
                value >>>= 7;
                break;
            }
        default:
            throw new Error('unreachable');
    }
    return buf;
}
function decodeUint8Array(buf, offset) {
    let b = buf[offset];
    let res = 0;
    res += b & REST;
    if (b < MSB) {
        return res;
    }
    b = buf[offset + 1];
    res += (b & REST) << 7;
    if (b < MSB) {
        return res;
    }
    b = buf[offset + 2];
    res += (b & REST) << 14;
    if (b < MSB) {
        return res;
    }
    b = buf[offset + 3];
    res += (b & REST) << 21;
    if (b < MSB) {
        return res;
    }
    b = buf[offset + 4];
    res += (b & REST) * N4;
    if (b < MSB) {
        return res;
    }
    b = buf[offset + 5];
    res += (b & REST) * N5;
    if (b < MSB) {
        return res;
    }
    b = buf[offset + 6];
    res += (b & REST) * N6;
    if (b < MSB) {
        return res;
    }
    b = buf[offset + 7];
    res += (b & REST) * N7;
    if (b < MSB) {
        return res;
    }
    throw new RangeError('Could not decode varint');
}
function decodeUint8ArrayList(buf, offset) {
    let b = buf.get(offset);
    let res = 0;
    res += b & REST;
    if (b < MSB) {
        return res;
    }
    b = buf.get(offset + 1);
    res += (b & REST) << 7;
    if (b < MSB) {
        return res;
    }
    b = buf.get(offset + 2);
    res += (b & REST) << 14;
    if (b < MSB) {
        return res;
    }
    b = buf.get(offset + 3);
    res += (b & REST) << 21;
    if (b < MSB) {
        return res;
    }
    b = buf.get(offset + 4);
    res += (b & REST) * N4;
    if (b < MSB) {
        return res;
    }
    b = buf.get(offset + 5);
    res += (b & REST) * N5;
    if (b < MSB) {
        return res;
    }
    b = buf.get(offset + 6);
    res += (b & REST) * N6;
    if (b < MSB) {
        return res;
    }
    b = buf.get(offset + 7);
    res += (b & REST) * N7;
    if (b < MSB) {
        return res;
    }
    throw new RangeError('Could not decode varint');
}
function encode(value, buf, offset = 0) {
    if (buf == null) {
        buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["allocUnsafe"])(encodingLength(value));
    }
    if (buf instanceof Uint8Array) {
        return encodeUint8Array(value, buf, offset);
    } else {
        return encodeUint8ArrayList(value, buf, offset);
    }
}
function decode(buf, offset = 0) {
    if (buf instanceof Uint8Array) {
        return decodeUint8Array(buf, offset);
    } else {
        return decodeUint8ArrayList(buf, offset);
    }
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/uint8arrays/dist/src/util/as-uint8array.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * To guarantee Uint8Array semantics, convert nodejs Buffers
 * into vanilla Uint8Arrays
 */ __turbopack_esm__({
    "asUint8Array": (()=>asUint8Array)
});
function asUint8Array(buf) {
    return buf;
} //# sourceMappingURL=as-uint8array.js.map
}}),
"[project]/node_modules/uint8arrays/dist/src/concat.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "concat": (()=>concat)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/uint8arrays/dist/src/alloc.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/uint8arrays/dist/src/util/as-uint8array.js [app-client] (ecmascript)");
;
;
function concat(arrays, length) {
    if (length == null) {
        length = arrays.reduce((acc, curr)=>acc + curr.length, 0);
    }
    const output = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["allocUnsafe"])(length);
    let offset = 0;
    for (const arr of arrays){
        output.set(arr, offset);
        offset += arr.length;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["asUint8Array"])(output);
} //# sourceMappingURL=concat.js.map
}}),
"[project]/node_modules/@chainsafe/is-ip/lib/parser.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/* eslint-disable @typescript-eslint/no-unsafe-return */ __turbopack_esm__({
    "Parser": (()=>Parser)
});
class Parser {
    index = 0;
    input = "";
    new(input) {
        this.index = 0;
        this.input = input;
        return this;
    }
    /** Run a parser, and restore the pre-parse state if it fails. */ readAtomically(fn) {
        const index = this.index;
        const result = fn();
        if (result === undefined) {
            this.index = index;
        }
        return result;
    }
    /** Run a parser, but fail if the entire input wasn't consumed. Doesn't run atomically. */ parseWith(fn) {
        const result = fn();
        if (this.index !== this.input.length) {
            return undefined;
        }
        return result;
    }
    /** Peek the next character from the input */ peekChar() {
        if (this.index >= this.input.length) {
            return undefined;
        }
        return this.input[this.index];
    }
    /** Read the next character from the input */ readChar() {
        if (this.index >= this.input.length) {
            return undefined;
        }
        return this.input[this.index++];
    }
    /** Read the next character from the input if it matches the target. */ readGivenChar(target) {
        return this.readAtomically(()=>{
            const char = this.readChar();
            if (char !== target) {
                return undefined;
            }
            return char;
        });
    }
    /**
     * Helper for reading separators in an indexed loop. Reads the separator
     * character iff index > 0, then runs the parser. When used in a loop,
     * the separator character will only be read on index > 0 (see
     * readIPv4Addr for an example)
     */ readSeparator(sep, index, inner) {
        return this.readAtomically(()=>{
            if (index > 0) {
                if (this.readGivenChar(sep) === undefined) {
                    return undefined;
                }
            }
            return inner();
        });
    }
    /**
     * Read a number off the front of the input in the given radix, stopping
     * at the first non-digit character or eof. Fails if the number has more
     * digits than max_digits or if there is no number.
     */ readNumber(radix, maxDigits, allowZeroPrefix, maxBytes) {
        return this.readAtomically(()=>{
            let result = 0;
            let digitCount = 0;
            const leadingChar = this.peekChar();
            if (leadingChar === undefined) {
                return undefined;
            }
            const hasLeadingZero = leadingChar === "0";
            const maxValue = 2 ** (8 * maxBytes) - 1;
            // eslint-disable-next-line no-constant-condition
            while(true){
                const digit = this.readAtomically(()=>{
                    const char = this.readChar();
                    if (char === undefined) {
                        return undefined;
                    }
                    const num = Number.parseInt(char, radix);
                    if (Number.isNaN(num)) {
                        return undefined;
                    }
                    return num;
                });
                if (digit === undefined) {
                    break;
                }
                result *= radix;
                result += digit;
                if (result > maxValue) {
                    return undefined;
                }
                digitCount += 1;
                if (maxDigits !== undefined) {
                    if (digitCount > maxDigits) {
                        return undefined;
                    }
                }
            }
            if (digitCount === 0) {
                return undefined;
            } else if (!allowZeroPrefix && hasLeadingZero && digitCount > 1) {
                return undefined;
            } else {
                return result;
            }
        });
    }
    /** Read an IPv4 address. */ readIPv4Addr() {
        return this.readAtomically(()=>{
            const out = new Uint8Array(4);
            for(let i = 0; i < out.length; i++){
                const ix = this.readSeparator(".", i, ()=>this.readNumber(10, 3, false, 1));
                if (ix === undefined) {
                    return undefined;
                }
                out[i] = ix;
            }
            return out;
        });
    }
    /** Read an IPv6 Address. */ readIPv6Addr() {
        /**
         * Read a chunk of an IPv6 address into `groups`. Returns the number
         * of groups read, along with a bool indicating if an embedded
         * trailing IPv4 address was read. Specifically, read a series of
         * colon-separated IPv6 groups (0x0000 - 0xFFFF), with an optional
         * trailing embedded IPv4 address.
         */ const readGroups = (groups)=>{
            for(let i = 0; i < groups.length / 2; i++){
                const ix = i * 2;
                // Try to read a trailing embedded IPv4 address. There must be at least 4 groups left.
                if (i < groups.length - 3) {
                    const ipv4 = this.readSeparator(":", i, ()=>this.readIPv4Addr());
                    if (ipv4 !== undefined) {
                        groups[ix] = ipv4[0];
                        groups[ix + 1] = ipv4[1];
                        groups[ix + 2] = ipv4[2];
                        groups[ix + 3] = ipv4[3];
                        return [
                            ix + 4,
                            true
                        ];
                    }
                }
                const group = this.readSeparator(":", i, ()=>this.readNumber(16, 4, true, 2));
                if (group === undefined) {
                    return [
                        ix,
                        false
                    ];
                }
                groups[ix] = group >> 8;
                groups[ix + 1] = group & 255;
            }
            return [
                groups.length,
                false
            ];
        };
        return this.readAtomically(()=>{
            // Read the front part of the address; either the whole thing, or up to the first ::
            const head = new Uint8Array(16);
            const [headSize, headIp4] = readGroups(head);
            if (headSize === 16) {
                return head;
            }
            // IPv4 part is not allowed before `::`
            if (headIp4) {
                return undefined;
            }
            // Read `::` if previous code parsed less than 8 groups.
            // `::` indicates one or more groups of 16 bits of zeros.
            if (this.readGivenChar(":") === undefined) {
                return undefined;
            }
            if (this.readGivenChar(":") === undefined) {
                return undefined;
            }
            // Read the back part of the address. The :: must contain at least one
            // set of zeroes, so our max length is 7.
            const tail = new Uint8Array(14);
            const limit = 16 - (headSize + 2);
            const [tailSize] = readGroups(tail.subarray(0, limit));
            // Concat the head and tail of the IP address
            head.set(tail.subarray(0, tailSize), 16 - tailSize);
            return head;
        });
    }
    /** Read an IP Address, either IPv4 or IPv6. */ readIPAddr() {
        return this.readIPv4Addr() ?? this.readIPv6Addr();
    }
} //# sourceMappingURL=parser.js.map
}}),
"[project]/node_modules/@chainsafe/is-ip/lib/parse.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "parseIP": (()=>parseIP),
    "parseIPv4": (()=>parseIPv4),
    "parseIPv4Mapped": (()=>parseIPv4Mapped),
    "parseIPv6": (()=>parseIPv6)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@chainsafe/is-ip/lib/parser.js [app-client] (ecmascript)");
;
// See https://stackoverflow.com/questions/166132/maximum-length-of-the-textual-representation-of-an-ipv6-address
const MAX_IPV6_LENGTH = 45;
const MAX_IPV4_LENGTH = 15;
const parser = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Parser"]();
function parseIPv4(input) {
    if (input.length > MAX_IPV4_LENGTH) {
        return undefined;
    }
    return parser.new(input).parseWith(()=>parser.readIPv4Addr());
}
function parseIPv4Mapped(input) {
    if (input.length > MAX_IPV4_LENGTH) {
        return undefined;
    }
    const ipv4 = parser.new(input).parseWith(()=>parser.readIPv4Addr());
    if (ipv4 === undefined) {
        return undefined;
    }
    return Uint8Array.from([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0xff,
        0xff,
        ipv4[0],
        ipv4[1],
        ipv4[2],
        ipv4[3]
    ]);
}
function parseIPv6(input) {
    // strip zone index if it is present
    if (input.includes("%")) {
        input = input.split("%")[0];
    }
    if (input.length > MAX_IPV6_LENGTH) {
        return undefined;
    }
    return parser.new(input).parseWith(()=>parser.readIPv6Addr());
}
function parseIP(input, mapIPv4ToIPv6 = false) {
    // strip zone index if it is present
    if (input.includes("%")) {
        input = input.split("%")[0];
    }
    if (input.length > MAX_IPV6_LENGTH) {
        return undefined;
    }
    const addr = parser.new(input).parseWith(()=>parser.readIPAddr());
    if (!addr) {
        return undefined;
    }
    if (mapIPv4ToIPv6 && addr.length === 4) {
        return Uint8Array.from([
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0xff,
            0xff,
            addr[0],
            addr[1],
            addr[2],
            addr[3]
        ]);
    }
    return addr;
} //# sourceMappingURL=parse.js.map
}}),
"[project]/node_modules/@chainsafe/netmask/dist/src/util.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "allFF": (()=>allFF),
    "deepEqual": (()=>deepEqual),
    "ipToString": (()=>ipToString),
    "maskToHex": (()=>maskToHex),
    "simpleMaskLength": (()=>simpleMaskLength)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$ip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@chainsafe/netmask/dist/src/ip.js [app-client] (ecmascript)");
;
function allFF(a, from, to) {
    let i = 0;
    for (const e of a){
        if (i < from) continue;
        if (i > to) break;
        if (e !== 0xff) return false;
        i++;
    }
    return true;
}
function deepEqual(a, b, from, to) {
    let i = 0;
    for (const e of a){
        if (i < from) continue;
        if (i > to) break;
        if (e !== b[i]) return false;
        i++;
    }
    return true;
}
function ipToString(ip) {
    switch(ip.length){
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$ip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IPv4Len"]:
            {
                return ip.join(".");
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$ip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IPv6Len"]:
            {
                const result = [];
                for(let i = 0; i < ip.length; i++){
                    if (i % 2 === 0) {
                        result.push(ip[i].toString(16).padStart(2, "0") + ip[i + 1].toString(16).padStart(2, "0"));
                    }
                }
                return result.join(":");
            }
        default:
            {
                throw new Error("Invalid ip length");
            }
    }
}
function simpleMaskLength(mask) {
    let ones = 0;
    // eslint-disable-next-line prefer-const
    for (let [index, byte] of mask.entries()){
        if (byte === 0xff) {
            ones += 8;
            continue;
        }
        while((byte & 0x80) != 0){
            ones++;
            byte = byte << 1;
        }
        if ((byte & 0x80) != 0) {
            return -1;
        }
        for(let i = index + 1; i < mask.length; i++){
            if (mask[i] != 0) {
                return -1;
            }
        }
        break;
    }
    return ones;
}
function maskToHex(mask) {
    let hex = "0x";
    for (const byte of mask){
        hex += (byte >> 4).toString(16) + (byte & 0x0f).toString(16);
    }
    return hex;
} //# sourceMappingURL=util.js.map
}}),
"[project]/node_modules/@chainsafe/netmask/dist/src/ip.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "IPv4Len": (()=>IPv4Len),
    "IPv6Len": (()=>IPv6Len),
    "containsIp": (()=>containsIp),
    "iPv4FromIPv6": (()=>iPv4FromIPv6),
    "ipv4Prefix": (()=>ipv4Prefix),
    "isIPv4mappedIPv6": (()=>isIPv4mappedIPv6),
    "maskIp": (()=>maskIp),
    "maxIPv6Octet": (()=>maxIPv6Octet)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@chainsafe/is-ip/lib/parse.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@chainsafe/netmask/dist/src/util.js [app-client] (ecmascript)");
;
;
const IPv4Len = 4;
const IPv6Len = 16;
const maxIPv6Octet = parseInt("0xFFFF", 16);
const ipv4Prefix = new Uint8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    255,
    255
]);
function maskIp(ip, mask) {
    if (mask.length === IPv6Len && ip.length === IPv4Len && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["allFF"])(mask, 0, 11)) {
        mask = mask.slice(12);
    }
    if (mask.length === IPv4Len && ip.length === IPv6Len && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepEqual"])(ip, ipv4Prefix, 0, 11)) {
        ip = ip.slice(12);
    }
    const n = ip.length;
    if (n != mask.length) {
        throw new Error("Failed to mask ip");
    }
    const out = new Uint8Array(n);
    for(let i = 0; i < n; i++){
        out[i] = ip[i] & mask[i];
    }
    return out;
}
function containsIp(net, ip) {
    if (typeof ip === "string") {
        ip = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseIP"])(ip);
    }
    if (ip == null) throw new Error("Invalid ip");
    if (ip.length !== net.network.length) {
        return false;
    }
    for(let i = 0; i < ip.length; i++){
        if ((net.network[i] & net.mask[i]) !== (ip[i] & net.mask[i])) {
            return false;
        }
    }
    return true;
}
function iPv4FromIPv6(ip) {
    if (!isIPv4mappedIPv6(ip)) {
        throw new Error("Must have 0xffff prefix");
    }
    return ip.slice(12);
}
function isIPv4mappedIPv6(ip) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepEqual"])(ip, ipv4Prefix, 0, 11);
} //# sourceMappingURL=ip.js.map
}}),
"[project]/node_modules/@chainsafe/netmask/dist/src/cidr.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "cidrMask": (()=>cidrMask),
    "parseCidr": (()=>parseCidr)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@chainsafe/is-ip/lib/parse.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$ip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@chainsafe/netmask/dist/src/ip.js [app-client] (ecmascript)");
;
;
function parseCidr(s) {
    const [address, maskString] = s.split("/");
    if (!address || !maskString) throw new Error("Failed to parse given CIDR: " + s);
    let ipLength = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$ip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IPv4Len"];
    let ip = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseIPv4"])(address);
    if (ip == null) {
        ipLength = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$ip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IPv6Len"];
        ip = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseIPv6"])(address);
        if (ip == null) throw new Error("Failed to parse given CIDR: " + s);
    }
    const m = parseInt(maskString, 10);
    if (Number.isNaN(m) || String(m).length !== maskString.length || m < 0 || m > ipLength * 8) {
        throw new Error("Failed to parse given CIDR: " + s);
    }
    const mask = cidrMask(m, 8 * ipLength);
    return {
        network: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$ip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["maskIp"])(ip, mask),
        mask
    };
}
function cidrMask(ones, bits) {
    if (bits !== 8 * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$ip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IPv4Len"] && bits !== 8 * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$ip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IPv6Len"]) throw new Error("Invalid CIDR mask");
    if (ones < 0 || ones > bits) throw new Error("Invalid CIDR mask");
    const l = bits / 8;
    const m = new Uint8Array(l);
    for(let i = 0; i < l; i++){
        if (ones >= 8) {
            m[i] = 0xff;
            ones -= 8;
            continue;
        }
        m[i] = 255 - (0xff >> ones);
        ones = 0;
    }
    return m;
} //# sourceMappingURL=cidr.js.map
}}),
"[project]/node_modules/@chainsafe/netmask/dist/src/ipnet.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "IpNet": (()=>IpNet)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@chainsafe/is-ip/lib/parse.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$cidr$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@chainsafe/netmask/dist/src/cidr.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$ip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@chainsafe/netmask/dist/src/ip.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@chainsafe/netmask/dist/src/util.js [app-client] (ecmascript)");
;
;
;
;
class IpNet {
    /**
     *
     * @param ipOrCidr either network ip or full cidr address
     * @param mask in case ipOrCidr is network this can be either mask in decimal format or as ip address
     */ constructor(ipOrCidr, mask){
        if (mask == null) {
            ({ network: this.network, mask: this.mask } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$cidr$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseCidr"])(ipOrCidr));
        } else {
            const ipResult = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseIP"])(ipOrCidr);
            if (ipResult == null) {
                throw new Error("Failed to parse network");
            }
            mask = String(mask);
            const m = parseInt(mask, 10);
            if (Number.isNaN(m) || String(m).length !== mask.length || m < 0 || m > ipResult.length * 8) {
                const maskResult = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseIP"])(mask);
                if (maskResult == null) {
                    throw new Error("Failed to parse mask");
                }
                this.mask = maskResult;
            } else {
                this.mask = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$cidr$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cidrMask"])(m, 8 * ipResult.length);
            }
            this.network = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$ip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["maskIp"])(ipResult, this.mask);
        }
    }
    /**
     * Checks if netmask contains ip address
     * @param ip
     * @returns
     */ contains(ip) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$ip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["containsIp"])({
            network: this.network,
            mask: this.mask
        }, ip);
    }
    /**Serializes back to string format */ toString() {
        const l = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["simpleMaskLength"])(this.mask);
        const mask = l !== -1 ? String(l) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["maskToHex"])(this.mask);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ipToString"])(this.network) + "/" + mask;
    }
} //# sourceMappingURL=ipnet.js.map
}}),
"[project]/node_modules/@chainsafe/netmask/dist/src/index.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "cidrContains": (()=>cidrContains)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$ipnet$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@chainsafe/netmask/dist/src/ipnet.js [app-client] (ecmascript)");
;
;
;
;
;
function cidrContains(cidr, ip) {
    const ipnet = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$ipnet$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IpNet"](cidr);
    return ipnet.contains(ip);
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@chainsafe/netmask/dist/src/index.js [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$ipnet$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@chainsafe/netmask/dist/src/ipnet.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@chainsafe/netmask/dist/src/util.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$ip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@chainsafe/netmask/dist/src/ip.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$cidr$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@chainsafe/netmask/dist/src/cidr.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@chainsafe/netmask/dist/src/index.js [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/uint8arrays/dist/src/from-string.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "fromString": (()=>fromString)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$bases$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/uint8arrays/dist/src/util/bases.js [app-client] (ecmascript)");
;
function fromString(string, encoding = 'utf8') {
    const base = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$bases$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"][encoding];
    if (base == null) {
        throw new Error(`Unsupported encoding "${encoding}"`);
    }
    // add multibase prefix
    return base.decoder.decode(`${base.prefix}${string}`); // eslint-disable-line @typescript-eslint/restrict-template-expressions
} //# sourceMappingURL=from-string.js.map
}}),
"[project]/node_modules/@chainsafe/is-ip/lib/is-ip.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ipVersion": (()=>ipVersion),
    "isIP": (()=>isIP),
    "isIPv4": (()=>isIPv4),
    "isIPv6": (()=>isIPv6)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@chainsafe/is-ip/lib/parse.js [app-client] (ecmascript)");
;
function isIPv4(input) {
    return Boolean((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseIPv4"])(input));
}
function isIPv6(input) {
    return Boolean((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseIPv6"])(input));
}
function isIP(input) {
    return Boolean((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseIP"])(input));
}
function ipVersion(input) {
    if (isIPv4(input)) {
        return 4;
    } else if (isIPv6(input)) {
        return 6;
    } else {
        return undefined;
    }
} //# sourceMappingURL=is-ip.js.map
}}),
"[project]/node_modules/@multiformats/multiaddr/dist/src/ip.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "isV4": (()=>isV4),
    "isV6": (()=>isV6),
    "toBytes": (()=>toBytes),
    "toString": (()=>toString)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$is$2d$ip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@chainsafe/is-ip/lib/is-ip.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/uint8arrays/dist/src/to-string.js [app-client] (ecmascript)");
;
;
;
const isV4 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$is$2d$ip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isIPv4"];
const isV6 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$is$2d$ip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isIPv6"];
const toBytes = function(ip) {
    let offset = 0;
    ip = ip.toString().trim();
    if (isV4(ip)) {
        const bytes = new Uint8Array(offset + 4);
        ip.split(/\./g).forEach((byte)=>{
            bytes[offset++] = parseInt(byte, 10) & 0xff;
        });
        return bytes;
    }
    if (isV6(ip)) {
        const sections = ip.split(':', 8);
        let i;
        for(i = 0; i < sections.length; i++){
            const isv4 = isV4(sections[i]);
            let v4Buffer;
            if (isv4) {
                v4Buffer = toBytes(sections[i]);
                sections[i] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toString"])(v4Buffer.slice(0, 2), 'base16');
            }
            if (v4Buffer != null && ++i < 8) {
                sections.splice(i, 0, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toString"])(v4Buffer.slice(2, 4), 'base16'));
            }
        }
        if (sections[0] === '') {
            while(sections.length < 8)sections.unshift('0');
        } else if (sections[sections.length - 1] === '') {
            while(sections.length < 8)sections.push('0');
        } else if (sections.length < 8) {
            for(i = 0; i < sections.length && sections[i] !== ''; i++);
            const argv = [
                i,
                1
            ];
            for(i = 9 - sections.length; i > 0; i--){
                argv.push('0');
            }
            sections.splice.apply(sections, argv);
        }
        const bytes = new Uint8Array(offset + 16);
        for(i = 0; i < sections.length; i++){
            const word = parseInt(sections[i], 16);
            bytes[offset++] = word >> 8 & 0xff;
            bytes[offset++] = word & 0xff;
        }
        return bytes;
    }
    throw new Error('invalid ip address');
};
const toString = function(buf, offset = 0, length) {
    offset = ~~offset;
    length = length ?? buf.length - offset;
    const view = new DataView(buf.buffer);
    if (length === 4) {
        const result = [];
        // IPv4
        for(let i = 0; i < length; i++){
            result.push(buf[offset + i]);
        }
        return result.join('.');
    }
    if (length === 16) {
        const result = [];
        // IPv6
        for(let i = 0; i < length; i += 2){
            result.push(view.getUint16(offset + i).toString(16));
        }
        return result.join(':').replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3').replace(/:{3,4}/, '::');
    }
    return '';
}; //# sourceMappingURL=ip.js.map
}}),
"[project]/node_modules/@multiformats/multiaddr/dist/src/ip.js [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$is$2d$ip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@chainsafe/is-ip/lib/is-ip.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/uint8arrays/dist/src/to-string.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$ip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@multiformats/multiaddr/dist/src/ip.js [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/@multiformats/multiaddr/dist/src/protocols-table.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "codes": (()=>codes),
    "createProtocol": (()=>createProtocol),
    "getProtocol": (()=>getProtocol),
    "names": (()=>names),
    "table": (()=>table)
});
const V = -1;
const names = {};
const codes = {};
const table = [
    [
        4,
        32,
        'ip4'
    ],
    [
        6,
        16,
        'tcp'
    ],
    [
        33,
        16,
        'dccp'
    ],
    [
        41,
        128,
        'ip6'
    ],
    [
        42,
        V,
        'ip6zone'
    ],
    [
        43,
        8,
        'ipcidr'
    ],
    [
        53,
        V,
        'dns',
        true
    ],
    [
        54,
        V,
        'dns4',
        true
    ],
    [
        55,
        V,
        'dns6',
        true
    ],
    [
        56,
        V,
        'dnsaddr',
        true
    ],
    [
        132,
        16,
        'sctp'
    ],
    [
        273,
        16,
        'udp'
    ],
    [
        275,
        0,
        'p2p-webrtc-star'
    ],
    [
        276,
        0,
        'p2p-webrtc-direct'
    ],
    [
        277,
        0,
        'p2p-stardust'
    ],
    [
        280,
        0,
        'webrtc-direct'
    ],
    [
        281,
        0,
        'webrtc'
    ],
    [
        290,
        0,
        'p2p-circuit'
    ],
    [
        301,
        0,
        'udt'
    ],
    [
        302,
        0,
        'utp'
    ],
    [
        400,
        V,
        'unix',
        false,
        true
    ],
    // `ipfs` is added before `p2p` for legacy support.
    // All text representations will default to `p2p`, but `ipfs` will
    // still be supported
    [
        421,
        V,
        'ipfs'
    ],
    // `p2p` is the preferred name for 421, and is now the default
    [
        421,
        V,
        'p2p'
    ],
    [
        443,
        0,
        'https'
    ],
    [
        444,
        96,
        'onion'
    ],
    [
        445,
        296,
        'onion3'
    ],
    [
        446,
        V,
        'garlic64'
    ],
    [
        448,
        0,
        'tls'
    ],
    [
        449,
        V,
        'sni'
    ],
    [
        460,
        0,
        'quic'
    ],
    [
        461,
        0,
        'quic-v1'
    ],
    [
        465,
        0,
        'webtransport'
    ],
    [
        466,
        V,
        'certhash'
    ],
    [
        477,
        0,
        'ws'
    ],
    [
        478,
        0,
        'wss'
    ],
    [
        479,
        0,
        'p2p-websocket-star'
    ],
    [
        480,
        0,
        'http'
    ],
    [
        481,
        V,
        'http-path'
    ],
    [
        777,
        V,
        'memory'
    ]
];
// populate tables
table.forEach((row)=>{
    const proto = createProtocol(...row);
    codes[proto.code] = proto;
    names[proto.name] = proto;
});
function createProtocol(code, size, name, resolvable, path) {
    return {
        code,
        size,
        name,
        resolvable: Boolean(resolvable),
        path: Boolean(path)
    };
}
function getProtocol(proto) {
    if (typeof proto === 'number') {
        if (codes[proto] != null) {
            return codes[proto];
        }
        throw new Error(`no protocol with code: ${proto}`);
    } else if (typeof proto === 'string') {
        if (names[proto] != null) {
            return names[proto];
        }
        throw new Error(`no protocol with name: ${proto}`);
    }
    throw new Error(`invalid protocol id type: ${typeof proto}`);
} //# sourceMappingURL=protocols-table.js.map
}}),
"[project]/node_modules/@multiformats/multiaddr/dist/src/ip.js [app-client] (ecmascript) <exports>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "isIP": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$is$2d$ip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isIP"]),
    "isV4": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$ip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isV4"]),
    "isV6": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$ip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isV6"]),
    "toBytes": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$ip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["toBytes"]),
    "toString": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$ip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["toString"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$is$2d$ip$2f$lib$2f$is$2d$ip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@chainsafe/is-ip/lib/is-ip.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$ip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@multiformats/multiaddr/dist/src/ip.js [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/@multiformats/multiaddr/dist/src/ip.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "isIP": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$ip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["isIP"]),
    "isV4": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$ip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["isV4"]),
    "isV6": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$ip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["isV6"]),
    "toBytes": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$ip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["toBytes"]),
    "toString": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$ip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["toString"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$ip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@multiformats/multiaddr/dist/src/ip.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$ip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__ = __turbopack_import__("[project]/node_modules/@multiformats/multiaddr/dist/src/ip.js [app-client] (ecmascript) <exports>");
}}),
"[project]/node_modules/@multiformats/multiaddr/dist/src/convert.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "convert": (()=>convert),
    "convertToBytes": (()=>convertToBytes),
    "convertToIpNet": (()=>convertToIpNet),
    "convertToString": (()=>convertToString)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@chainsafe/netmask/dist/src/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/base32.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/base58.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$basics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/basics.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/cid.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/hashes/digest.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8$2d$varint$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/uint8-varint/dist/src/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$concat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/uint8arrays/dist/src/concat.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$from$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/uint8arrays/dist/src/from-string.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/uint8arrays/dist/src/to-string.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$ip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@multiformats/multiaddr/dist/src/ip.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@multiformats/multiaddr/dist/src/protocols-table.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$ipnet$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@chainsafe/netmask/dist/src/ipnet.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$basics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/basics.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$ip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@multiformats/multiaddr/dist/src/ip.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/cid.js [app-client] (ecmascript) <locals>");
;
;
;
;
;
;
;
;
;
;
;
;
const ip4Protocol = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getProtocol"])('ip4');
const ip6Protocol = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getProtocol"])('ip6');
const ipcidrProtocol = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getProtocol"])('ipcidr');
function convert(proto, a) {
    if (a instanceof Uint8Array) {
        return convertToString(proto, a);
    } else {
        return convertToBytes(proto, a);
    }
}
function convertToString(proto, buf) {
    const protocol = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getProtocol"])(proto);
    switch(protocol.code){
        case 4:
        case 41:
            return bytes2ip(buf);
        case 42:
            return bytes2str(buf);
        case 43:
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toString"])(buf, 'base10');
        case 6:
        case 273:
        case 33:
        case 132:
            return bytes2port(buf).toString();
        case 53:
        case 54:
        case 55:
        case 56:
        case 400:
        case 449:
        case 777:
            return bytes2str(buf);
        case 421:
            return bytes2mh(buf);
        case 444:
            return bytes2onion(buf);
        case 445:
            return bytes2onion(buf);
        case 466:
            return bytes2mb(buf);
        case 481:
            return globalThis.encodeURIComponent(bytes2str(buf));
        default:
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toString"])(buf, 'base16'); // no clue. convert to hex
    }
}
function convertToBytes(proto, str) {
    const protocol = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getProtocol"])(proto);
    switch(protocol.code){
        case 4:
            return ip2bytes(str);
        case 41:
            return ip2bytes(str);
        case 42:
            return str2bytes(str);
        case 43:
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$from$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromString"])(str, 'base10');
        case 6:
        case 273:
        case 33:
        case 132:
            return port2bytes(parseInt(str, 10));
        case 53:
        case 54:
        case 55:
        case 56:
        case 400:
        case 449:
        case 777:
            return str2bytes(str);
        case 421:
            return mh2bytes(str);
        case 444:
            return onion2bytes(str);
        case 445:
            return onion32bytes(str);
        case 466:
            return mb2bytes(str);
        case 481:
            return str2bytes(globalThis.decodeURIComponent(str));
        default:
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$from$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromString"])(str, 'base16'); // no clue. convert from hex
    }
}
function convertToIpNet(multiaddr) {
    let mask;
    let addr;
    multiaddr.stringTuples().forEach(([code, value])=>{
        if (code === ip4Protocol.code || code === ip6Protocol.code) {
            addr = value;
        }
        if (code === ipcidrProtocol.code) {
            mask = value;
        }
    });
    if (mask == null || addr == null) {
        throw new Error('Invalid multiaddr');
    }
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chainsafe$2f$netmask$2f$dist$2f$src$2f$ipnet$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IpNet"](addr, mask);
}
const decoders = Object.values(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$basics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bases"]).map((c)=>c.decoder);
const anybaseDecoder = function() {
    let acc = decoders[0].or(decoders[1]);
    decoders.slice(2).forEach((d)=>acc = acc.or(d));
    return acc;
}();
function ip2bytes(ipString) {
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$ip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.isIP(ipString)) {
        throw new Error('invalid ip address');
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$ip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.toBytes(ipString);
}
function bytes2ip(ipBuff) {
    const ipString = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$ip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.toString(ipBuff, 0, ipBuff.length);
    if (ipString == null) {
        throw new Error('ipBuff is required');
    }
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$ip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.isIP(ipString)) {
        throw new Error('invalid ip address');
    }
    return ipString;
}
function port2bytes(port) {
    const buf = new ArrayBuffer(2);
    const view = new DataView(buf);
    view.setUint16(0, port);
    return new Uint8Array(buf);
}
function bytes2port(buf) {
    const view = new DataView(buf.buffer);
    return view.getUint16(buf.byteOffset);
}
function str2bytes(str) {
    const buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$from$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromString"])(str);
    const size = Uint8Array.from(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8$2d$varint$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.encode(buf.length));
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$concat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["concat"])([
        size,
        buf
    ], size.length + buf.length);
}
function bytes2str(buf) {
    const size = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8$2d$varint$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.decode(buf);
    buf = buf.slice(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8$2d$varint$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.encodingLength(size));
    if (buf.length !== size) {
        throw new Error('inconsistent lengths');
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toString"])(buf);
}
function mh2bytes(hash) {
    let mh;
    if (hash[0] === 'Q' || hash[0] === '1') {
        mh = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.decode(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base58btc"].decode(`z${hash}`)).bytes;
    } else {
        mh = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].parse(hash).multihash.bytes;
    }
    // the address is a varint prefixed multihash string representation
    const size = Uint8Array.from(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8$2d$varint$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.encode(mh.length));
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$concat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["concat"])([
        size,
        mh
    ], size.length + mh.length);
}
function mb2bytes(mbstr) {
    const mb = anybaseDecoder.decode(mbstr);
    const size = Uint8Array.from(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8$2d$varint$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.encode(mb.length));
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$concat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["concat"])([
        size,
        mb
    ], size.length + mb.length);
}
function bytes2mb(buf) {
    const size = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8$2d$varint$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.decode(buf);
    const hash = buf.slice(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8$2d$varint$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.encodingLength(size));
    if (hash.length !== size) {
        throw new Error('inconsistent lengths');
    }
    return 'u' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toString"])(hash, 'base64url');
}
/**
 * Converts bytes to bas58btc string
 */ function bytes2mh(buf) {
    const size = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8$2d$varint$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.decode(buf);
    const address = buf.slice(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8$2d$varint$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.encodingLength(size));
    if (address.length !== size) {
        throw new Error('inconsistent lengths');
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toString"])(address, 'base58btc');
}
function onion2bytes(str) {
    const addr = str.split(':');
    if (addr.length !== 2) {
        throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
    }
    if (addr[0].length !== 16) {
        throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);
    }
    // onion addresses do not include the multibase prefix, add it before decoding
    const buf = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base32"].decode('b' + addr[0]);
    // onion port number
    const port = parseInt(addr[1], 10);
    if (port < 1 || port > 65536) {
        throw new Error('Port number is not in range(1, 65536)');
    }
    const portBuf = port2bytes(port);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$concat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["concat"])([
        buf,
        portBuf
    ], buf.length + portBuf.length);
}
function onion32bytes(str) {
    const addr = str.split(':');
    if (addr.length !== 2) {
        throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
    }
    if (addr[0].length !== 56) {
        throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);
    }
    // onion addresses do not include the multibase prefix, add it before decoding
    const buf = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base32"].decode(`b${addr[0]}`);
    // onion port number
    const port = parseInt(addr[1], 10);
    if (port < 1 || port > 65536) {
        throw new Error('Port number is not in range(1, 65536)');
    }
    const portBuf = port2bytes(port);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$concat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["concat"])([
        buf,
        portBuf
    ], buf.length + portBuf.length);
}
function bytes2onion(buf) {
    const addrBytes = buf.slice(0, buf.length - 2);
    const portBytes = buf.slice(buf.length - 2);
    const addr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toString"])(addrBytes, 'base32');
    const port = bytes2port(portBytes);
    return `${addr}:${port}`;
} //# sourceMappingURL=convert.js.map
}}),
"[project]/node_modules/@multiformats/multiaddr/dist/src/codec.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ParseError": (()=>ParseError),
    "bytesToMultiaddrParts": (()=>bytesToMultiaddrParts),
    "bytesToTuples": (()=>bytesToTuples),
    "cleanPath": (()=>cleanPath),
    "stringToMultiaddrParts": (()=>stringToMultiaddrParts),
    "tuplesToBytes": (()=>tuplesToBytes)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8$2d$varint$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/uint8-varint/dist/src/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$concat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/uint8arrays/dist/src/concat.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/uint8arrays/dist/src/to-string.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$convert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@multiformats/multiaddr/dist/src/convert.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@multiformats/multiaddr/dist/src/protocols-table.js [app-client] (ecmascript)");
;
;
;
;
;
function stringToMultiaddrParts(str) {
    str = cleanPath(str);
    const tuples = [];
    const stringTuples = [];
    let path = null;
    const parts = str.split('/').slice(1);
    if (parts.length === 1 && parts[0] === '') {
        return {
            bytes: new Uint8Array(),
            string: '/',
            tuples: [],
            stringTuples: [],
            path: null
        };
    }
    for(let p = 0; p < parts.length; p++){
        const part = parts[p];
        const proto = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getProtocol"])(part);
        if (proto.size === 0) {
            tuples.push([
                proto.code
            ]);
            stringTuples.push([
                proto.code
            ]);
            continue;
        }
        p++; // advance addr part
        if (p >= parts.length) {
            throw new ParseError('invalid address: ' + str);
        }
        // if it's a path proto, take the rest
        if (proto.path === true) {
            // should we need to check each path part to see if it's a proto?
            // This would allow for other protocols to be added after a unix path,
            // however it would have issues if the path had a protocol name in the path
            path = cleanPath(parts.slice(p).join('/'));
            tuples.push([
                proto.code,
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$convert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertToBytes"])(proto.code, path)
            ]);
            stringTuples.push([
                proto.code,
                path
            ]);
            break;
        }
        const bytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$convert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertToBytes"])(proto.code, parts[p]);
        tuples.push([
            proto.code,
            bytes
        ]);
        stringTuples.push([
            proto.code,
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$convert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertToString"])(proto.code, bytes)
        ]);
    }
    return {
        string: stringTuplesToString(stringTuples),
        bytes: tuplesToBytes(tuples),
        tuples,
        stringTuples,
        path
    };
}
function bytesToMultiaddrParts(bytes) {
    const tuples = [];
    const stringTuples = [];
    let path = null;
    let i = 0;
    while(i < bytes.length){
        const code = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8$2d$varint$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.decode(bytes, i);
        const n = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8$2d$varint$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.encodingLength(code);
        const p = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getProtocol"])(code);
        const size = sizeForAddr(p, bytes.slice(i + n));
        if (size === 0) {
            tuples.push([
                code
            ]);
            stringTuples.push([
                code
            ]);
            i += n;
            continue;
        }
        const addr = bytes.slice(i + n, i + n + size);
        i += size + n;
        if (i > bytes.length) {
            throw new ParseError('Invalid address Uint8Array: ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toString"])(bytes, 'base16'));
        }
        // ok, tuple seems good.
        tuples.push([
            code,
            addr
        ]);
        const stringAddr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$convert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertToString"])(code, addr);
        stringTuples.push([
            code,
            stringAddr
        ]);
        if (p.path === true) {
            // should we need to check each path part to see if it's a proto?
            // This would allow for other protocols to be added after a unix path,
            // however it would have issues if the path had a protocol name in the path
            path = stringAddr;
            break;
        }
    }
    return {
        bytes: Uint8Array.from(bytes),
        string: stringTuplesToString(stringTuples),
        tuples,
        stringTuples,
        path
    };
}
/**
 * [[str name, str addr]... ] -> string
 */ function stringTuplesToString(tuples) {
    const parts = [];
    tuples.map((tup)=>{
        const proto = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getProtocol"])(tup[0]);
        parts.push(proto.name);
        if (tup.length > 1 && tup[1] != null) {
            parts.push(tup[1]);
        }
        return null;
    });
    return cleanPath(parts.join('/'));
}
function tuplesToBytes(tuples) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$concat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["concat"])(tuples.map((tup)=>{
        const proto = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getProtocol"])(tup[0]);
        let buf = Uint8Array.from(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8$2d$varint$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.encode(proto.code));
        if (tup.length > 1 && tup[1] != null) {
            buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$concat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["concat"])([
                buf,
                tup[1]
            ]); // add address buffer
        }
        return buf;
    }));
}
/**
 * For the passed address, return the serialized size
 */ function sizeForAddr(p, addr) {
    if (p.size > 0) {
        return p.size / 8;
    } else if (p.size === 0) {
        return 0;
    } else {
        const size = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8$2d$varint$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.decode(addr instanceof Uint8Array ? addr : Uint8Array.from(addr));
        return size + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8$2d$varint$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.encodingLength(size);
    }
}
function bytesToTuples(buf) {
    const tuples = [];
    let i = 0;
    while(i < buf.length){
        const code = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8$2d$varint$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.decode(buf, i);
        const n = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8$2d$varint$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.encodingLength(code);
        const p = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getProtocol"])(code);
        const size = sizeForAddr(p, buf.slice(i + n));
        if (size === 0) {
            tuples.push([
                code
            ]);
            i += n;
            continue;
        }
        const addr = buf.slice(i + n, i + n + size);
        i += size + n;
        if (i > buf.length) {
            throw new ParseError('Invalid address Uint8Array: ' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toString"])(buf, 'base16'));
        }
        // ok, tuple seems good.
        tuples.push([
            code,
            addr
        ]);
    }
    return tuples;
}
function cleanPath(str) {
    return '/' + str.trim().split('/').filter((a)=>a).join('/');
}
class ParseError extends Error {
    static name = 'ParseError';
    name = 'ParseError';
    constructor(str){
        super(`Error parsing address: ${str}`);
    }
} //# sourceMappingURL=codec.js.map
}}),
"[project]/node_modules/@multiformats/multiaddr/dist/src/index.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @packageDocumentation
 *
 * A standard way to represent addresses that
 *
 * - support any standard network protocol
 * - are self-describing
 * - have a binary packed format
 * - have a nice string representation
 * - encapsulate well
 *
 * @example
 *
 * ```TypeScript
 * import { multiaddr } from '@multiformats/multiaddr'
 *
 * const addr = multiaddr('/ip4/127.0.0.1/udp/1234')
 * // Multiaddr(/ip4/127.0.0.1/udp/1234)
 *
 * addr.bytes
 * // <Uint8Array 04 7f 00 00 01 11 04 d2>
 *
 * addr.toString()
 * // '/ip4/127.0.0.1/udp/1234'
 *
 * addr.protos()
 * // [
 * //   {code: 4, name: 'ip4', size: 32},
 * //   {code: 273, name: 'udp', size: 16}
 * // ]
 *
 * // gives you an object that is friendly with what Node.js core modules expect for addresses
 * addr.nodeAddress()
 * // {
 * //   family: 4,
 * //   port: 1234,
 * //   address: "127.0.0.1"
 * // }
 *
 * addr.encapsulate('/sctp/5678')
 * // Multiaddr(/ip4/127.0.0.1/udp/1234/sctp/5678)
 * ```
 *
 * ## Resolving DNSADDR addresses
 *
 * [DNSADDR](https://github.com/multiformats/multiaddr/blob/master/protocols/DNSADDR.md) is a spec that allows storing a TXT DNS record that contains a Multiaddr.
 *
 * To resolve DNSADDR addresses, call the `.resolve()` function the multiaddr, optionally passing a `DNS` resolver.
 *
 * DNSADDR addresses can resolve to multiple multiaddrs, since there is no limit to the number of TXT records that can be stored.
 *
 * @example Resolving DNSADDR Multiaddrs
 *
 * ```TypeScript
 * import { multiaddr, resolvers } from '@multiformats/multiaddr'
 * import { dnsaddrResolver } from '@multiformats/multiaddr/resolvers'
 *
 * resolvers.set('dnsaddr', dnsaddrResolver)
 *
 * const ma = multiaddr('/dnsaddr/bootstrap.libp2p.io')
 *
 * // resolve with a 5s timeout
 * const resolved = await ma.resolve({
 *   signal: AbortSignal.timeout(5000)
 * })
 *
 * console.info(resolved)
 * // [Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...')...]
 * ```
 *
 * @example Using a custom DNS resolver to resolve DNSADDR Multiaddrs
 *
 * See the docs for [@multiformats/dns](https://www.npmjs.com/package/@multiformats/dns) for a full breakdown of how to specify multiple resolvers or resolvers that can be used for specific TLDs.
 *
 * ```TypeScript
 * import { multiaddr } from '@multiformats/multiaddr'
 * import { dns } from '@multiformats/dns'
 * import { dnsJsonOverHttps } from '@multiformats/dns/resolvers'
 *
 * const resolver = dns({
 *   resolvers: {
 *     '.': dnsJsonOverHttps('https://cloudflare-dns.com/dns-query')
 *   }
 * })
 *
 * const ma = multiaddr('/dnsaddr/bootstrap.libp2p.io')
 * const resolved = await ma.resolve({
 *  dns: resolver
 * })
 *
 * console.info(resolved)
 * // [Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...')...]
 * ```
 */ __turbopack_esm__({
    "fromNodeAddress": (()=>fromNodeAddress),
    "isMultiaddr": (()=>isMultiaddr),
    "isName": (()=>isName),
    "multiaddr": (()=>multiaddr),
    "resolvers": (()=>resolvers)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$multiaddr$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@multiformats/multiaddr/dist/src/multiaddr.js [app-client] (ecmascript)");
;
;
const resolvers = new Map();
;
function fromNodeAddress(addr, transport) {
    if (addr == null) {
        throw new Error('requires node address object');
    }
    if (transport == null) {
        throw new Error('requires transport protocol');
    }
    let ip;
    let host = addr.address;
    switch(addr.family){
        case 4:
            ip = 'ip4';
            break;
        case 6:
            ip = 'ip6';
            if (host.includes('%')) {
                const parts = host.split('%');
                if (parts.length !== 2) {
                    throw Error('Multiple ip6 zones in multiaddr');
                }
                host = parts[0];
                const zone = parts[1];
                ip = `/ip6zone/${zone}/ip6`;
            }
            break;
        default:
            throw Error('Invalid addr family, should be 4 or 6.');
    }
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$multiaddr$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Multiaddr"]('/' + [
        ip,
        host,
        transport,
        addr.port
    ].join('/'));
}
function isName(addr) {
    if (!isMultiaddr(addr)) {
        return false;
    }
    // if a part of the multiaddr is resolvable, then return true
    return addr.protos().some((proto)=>proto.resolvable);
}
function isMultiaddr(value) {
    return Boolean(value?.[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$multiaddr$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["symbol"]]);
}
function multiaddr(addr) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$multiaddr$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Multiaddr"](addr);
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@multiformats/multiaddr/dist/src/multiaddr.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/* eslint-disable complexity */ __turbopack_esm__({
    "Multiaddr": (()=>Multiaddr),
    "symbol": (()=>symbol)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/base58.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/cid.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$equals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/uint8arrays/dist/src/equals.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/uint8arrays/dist/src/to-string.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$codec$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@multiformats/multiaddr/dist/src/codec.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@multiformats/multiaddr/dist/src/protocols-table.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@multiformats/multiaddr/dist/src/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@multiformats/multiaddr/dist/src/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/cid.js [app-client] (ecmascript) <locals>");
;
;
;
;
;
;
;
const inspect = Symbol.for('nodejs.util.inspect.custom');
const symbol = Symbol.for('@multiformats/js-multiaddr/multiaddr');
const DNS_CODES = [
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getProtocol"])('dns').code,
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getProtocol"])('dns4').code,
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getProtocol"])('dns6').code,
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getProtocol"])('dnsaddr').code
];
class NoAvailableResolverError extends Error {
    constructor(message = 'No available resolver'){
        super(message);
        this.name = 'NoAvailableResolverError';
    }
}
class Multiaddr {
    bytes;
    #string;
    #tuples;
    #stringTuples;
    #path;
    [symbol] = true;
    constructor(addr){
        // default
        if (addr == null) {
            addr = '';
        }
        let parts;
        if (addr instanceof Uint8Array) {
            parts = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$codec$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bytesToMultiaddrParts"])(addr);
        } else if (typeof addr === 'string') {
            if (addr.length > 0 && addr.charAt(0) !== '/') {
                throw new Error(`multiaddr "${addr}" must start with a "/"`);
            }
            parts = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$codec$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringToMultiaddrParts"])(addr);
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isMultiaddr"])(addr)) {
            parts = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$codec$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bytesToMultiaddrParts"])(addr.bytes);
        } else {
            throw new Error('addr must be a string, Buffer, or another Multiaddr');
        }
        this.bytes = parts.bytes;
        this.#string = parts.string;
        this.#tuples = parts.tuples;
        this.#stringTuples = parts.stringTuples;
        this.#path = parts.path;
    }
    toString() {
        return this.#string;
    }
    toJSON() {
        return this.toString();
    }
    toOptions() {
        let family;
        let transport;
        let host;
        let port;
        let zone = '';
        const tcp = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getProtocol"])('tcp');
        const udp = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getProtocol"])('udp');
        const ip4 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getProtocol"])('ip4');
        const ip6 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getProtocol"])('ip6');
        const dns6 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getProtocol"])('dns6');
        const ip6zone = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getProtocol"])('ip6zone');
        for (const [code, value] of this.stringTuples()){
            if (code === ip6zone.code) {
                zone = `%${value ?? ''}`;
            }
            // default to https when protocol & port are omitted from DNS addrs
            if (DNS_CODES.includes(code)) {
                transport = tcp.name === 'tcp' ? 'tcp' : 'udp';
                port = 443;
                host = `${value ?? ''}${zone}`;
                family = code === dns6.code ? 6 : 4;
            }
            if (code === tcp.code || code === udp.code) {
                transport = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getProtocol"])(code).name === 'tcp' ? 'tcp' : 'udp';
                port = parseInt(value ?? '');
            }
            if (code === ip4.code || code === ip6.code) {
                transport = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getProtocol"])(code).name === 'tcp' ? 'tcp' : 'udp';
                host = `${value ?? ''}${zone}`;
                family = code === ip6.code ? 6 : 4;
            }
        }
        if (family == null || transport == null || host == null || port == null) {
            throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');
        }
        const opts = {
            family,
            host,
            transport,
            port
        };
        return opts;
    }
    protos() {
        return this.#tuples.map(([code])=>Object.assign({}, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getProtocol"])(code)));
    }
    protoCodes() {
        return this.#tuples.map(([code])=>code);
    }
    protoNames() {
        return this.#tuples.map(([code])=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getProtocol"])(code).name);
    }
    tuples() {
        return this.#tuples.map(([code, value])=>{
            if (value == null) {
                return [
                    code
                ];
            }
            return [
                code,
                value
            ];
        });
    }
    stringTuples() {
        return this.#stringTuples.map(([code, value])=>{
            if (value == null) {
                return [
                    code
                ];
            }
            return [
                code,
                value
            ];
        });
    }
    encapsulate(addr) {
        addr = new Multiaddr(addr);
        return new Multiaddr(this.toString() + addr.toString());
    }
    decapsulate(addr) {
        const addrString = addr.toString();
        const s = this.toString();
        const i = s.lastIndexOf(addrString);
        if (i < 0) {
            throw new Error(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`);
        }
        return new Multiaddr(s.slice(0, i));
    }
    decapsulateCode(code) {
        const tuples = this.tuples();
        for(let i = tuples.length - 1; i >= 0; i--){
            if (tuples[i][0] === code) {
                return new Multiaddr((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$codec$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["tuplesToBytes"])(tuples.slice(0, i)));
            }
        }
        return this;
    }
    getPeerId() {
        try {
            let tuples = [];
            this.stringTuples().forEach(([code, name])=>{
                if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["names"].p2p.code) {
                    tuples.push([
                        code,
                        name
                    ]);
                }
                // if this is a p2p-circuit address, return the target peer id if present
                // not the peer id of the relay
                if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["names"]['p2p-circuit'].code) {
                    tuples = [];
                }
            });
            // Get the last ipfs tuple ['p2p', 'peerid string']
            const tuple = tuples.pop();
            if (tuple?.[1] != null) {
                const peerIdStr = tuple[1];
                // peer id is base58btc encoded string but not multibase encoded so add the `z`
                // prefix so we can validate that it is correctly encoded
                if (peerIdStr[0] === 'Q' || peerIdStr[0] === '1') {
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toString"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base58btc"].decode(`z${peerIdStr}`), 'base58btc');
                }
                // try to parse peer id as CID
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toString"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].parse(peerIdStr).multihash.bytes, 'base58btc');
            }
            return null;
        } catch (e) {
            return null;
        }
    }
    getPath() {
        return this.#path;
    }
    equals(addr) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$equals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["equals"])(this.bytes, addr.bytes);
    }
    async resolve(options) {
        const resolvableProto = this.protos().find((p)=>p.resolvable);
        // Multiaddr is not resolvable?
        if (resolvableProto == null) {
            return [
                this
            ];
        }
        const resolver = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["resolvers"].get(resolvableProto.name);
        if (resolver == null) {
            throw new NoAvailableResolverError(`no available resolver for ${resolvableProto.name}`);
        }
        const result = await resolver(this, options);
        return result.map((str)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["multiaddr"])(str));
    }
    nodeAddress() {
        const options = this.toOptions();
        if (options.transport !== 'tcp' && options.transport !== 'udp') {
            throw new Error(`multiaddr must have a valid format - no protocol with name: "${options.transport}". Must have a valid transport protocol: "{tcp, udp}"`);
        }
        return {
            family: options.family,
            address: options.host,
            port: options.port
        };
    }
    isThinWaistAddress(addr) {
        const protos = (addr ?? this).protos();
        if (protos.length !== 2) {
            return false;
        }
        if (protos[0].code !== 4 && protos[0].code !== 41) {
            return false;
        }
        if (protos[1].code !== 6 && protos[1].code !== 273) {
            return false;
        }
        return true;
    }
    /**
     * Returns Multiaddr as a human-readable string
     * https://nodejs.org/api/util.html#utilinspectcustom
     *
     * @example
     * ```js
     * import { multiaddr } from '@multiformats/multiaddr'
     *
     * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))
     * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'
     * ```
     */ [inspect]() {
        return `Multiaddr(${this.#string})`;
    }
} //# sourceMappingURL=multiaddr.js.map
}}),
"[project]/node_modules/@multiformats/multiaddr/dist/src/filter/multiaddr-filter.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "MultiaddrFilter": (()=>MultiaddrFilter)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$convert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@multiformats/multiaddr/dist/src/convert.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@multiformats/multiaddr/dist/src/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@multiformats/multiaddr/dist/src/index.js [app-client] (ecmascript) <locals>");
;
;
class MultiaddrFilter {
    multiaddr;
    netmask;
    constructor(input){
        this.multiaddr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["multiaddr"])(input);
        this.netmask = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$convert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertToIpNet"])(this.multiaddr);
    }
    contains(input) {
        if (input == null) return false;
        const m = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["multiaddr"])(input);
        let ip;
        for (const [code, value] of m.stringTuples()){
            if (code === 4 || code === 41) {
                ip = value;
                break;
            }
        }
        if (ip === undefined) return false;
        return this.netmask.contains(ip);
    }
} //# sourceMappingURL=multiaddr-filter.js.map
}}),
"[project]/node_modules/@multiformats/multiaddr/dist/src/index.js [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$multiaddr$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@multiformats/multiaddr/dist/src/multiaddr.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$protocols$2d$table$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@multiformats/multiaddr/dist/src/protocols-table.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$filter$2f$multiaddr$2d$filter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@multiformats/multiaddr/dist/src/filter/multiaddr-filter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@multiformats/multiaddr/dist/src/index.js [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/@multiformats/mafmt/dist/src/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Circuit": (()=>Circuit),
    "DNS": (()=>DNS),
    "DNS4": (()=>DNS4),
    "DNS6": (()=>DNS6),
    "DNSADDR": (()=>DNSADDR),
    "HTTP": (()=>HTTP),
    "HTTPS": (()=>HTTPS),
    "IP": (()=>IP),
    "IPFS": (()=>IPFS),
    "P2P": (()=>P2P),
    "P2PWebRTCDirect": (()=>P2PWebRTCDirect),
    "P2PWebRTCStar": (()=>P2PWebRTCStar),
    "QUIC": (()=>QUIC),
    "QUICV1": (()=>QUICV1),
    "Reliable": (()=>Reliable),
    "Stardust": (()=>Stardust),
    "TCP": (()=>TCP),
    "UDP": (()=>UDP),
    "UTP": (()=>UTP),
    "WebRTC": (()=>WebRTC),
    "WebRTCDirect": (()=>WebRTCDirect),
    "WebSocketStar": (()=>WebSocketStar),
    "WebSockets": (()=>WebSockets),
    "WebSocketsSecure": (()=>WebSocketsSecure),
    "WebTransport": (()=>WebTransport)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@multiformats/multiaddr/dist/src/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@multiformats/multiaddr/dist/src/index.js [app-client] (ecmascript) <locals>");
;
const DNS4 = base('dns4');
const DNS6 = base('dns6');
const DNSADDR = base('dnsaddr');
const DNS = or(base('dns'), DNSADDR, DNS4, DNS6);
const IP = or(base('ip4'), base('ip6'));
const TCP = or(and(IP, base('tcp')), and(DNS, base('tcp')));
const UDP = and(IP, base('udp'));
const UTP = and(UDP, base('utp'));
const QUIC = and(UDP, base('quic'));
const QUICV1 = and(UDP, base('quic-v1'));
const _WebSockets = or(and(TCP, base('ws')), and(DNS, base('ws')));
const WebSockets = or(and(_WebSockets, base('p2p')), _WebSockets);
const _WebSocketsSecure = or(and(TCP, base('wss')), and(DNS, base('wss')), and(TCP, base('tls'), base('ws')), and(DNS, base('tls'), base('ws')));
const WebSocketsSecure = or(and(_WebSocketsSecure, base('p2p')), _WebSocketsSecure);
const HTTP = or(and(TCP, base('http')), and(IP, base('http')), and(DNS, base('http')));
const HTTPS = or(and(TCP, base('https')), and(IP, base('https')), and(DNS, base('https')));
const _WebRTCDirect = and(UDP, base('webrtc-direct'), base('certhash'));
const WebRTCDirect = or(and(_WebRTCDirect, base('p2p')), _WebRTCDirect);
const _WebTransport = and(QUICV1, base('webtransport'), base('certhash'), base('certhash'));
const WebTransport = or(and(_WebTransport, base('p2p')), _WebTransport);
const P2PWebRTCStar = or(and(WebSockets, base('p2p-webrtc-star'), base('p2p')), and(WebSocketsSecure, base('p2p-webrtc-star'), base('p2p')), and(WebSockets, base('p2p-webrtc-star')), and(WebSocketsSecure, base('p2p-webrtc-star')));
const WebSocketStar = or(and(WebSockets, base('p2p-websocket-star'), base('p2p')), and(WebSocketsSecure, base('p2p-websocket-star'), base('p2p')), and(WebSockets, base('p2p-websocket-star')), and(WebSocketsSecure, base('p2p-websocket-star')));
const P2PWebRTCDirect = or(and(HTTP, base('p2p-webrtc-direct'), base('p2p')), and(HTTPS, base('p2p-webrtc-direct'), base('p2p')), and(HTTP, base('p2p-webrtc-direct')), and(HTTPS, base('p2p-webrtc-direct')));
const Reliable = or(_WebSockets, _WebSocketsSecure, HTTP, HTTPS, P2PWebRTCStar, P2PWebRTCDirect, TCP, UTP, QUIC, DNS, WebRTCDirect, WebTransport);
const Stardust = or(and(Reliable, base('p2p-stardust'), base('p2p')), and(Reliable, base('p2p-stardust')));
const _P2P = or(and(Reliable, base('p2p')), P2PWebRTCStar, P2PWebRTCDirect, WebRTCDirect, WebTransport, base('p2p'));
const _Circuit = or(and(_P2P, base('p2p-circuit'), _P2P), and(_P2P, base('p2p-circuit')), and(base('p2p-circuit'), _P2P), and(Reliable, base('p2p-circuit')), and(base('p2p-circuit'), Reliable), base('p2p-circuit'));
const CircuitRecursive = ()=>or(and(_Circuit, CircuitRecursive), _Circuit);
const Circuit = CircuitRecursive();
const P2P = or(and(Circuit, _P2P, Circuit), and(_P2P, Circuit), and(Circuit, _P2P), Circuit, _P2P);
const IPFS = P2P;
const WebRTC = or(and(Circuit, base('webrtc'), base('p2p')), and(Circuit, base('webrtc')), and(Reliable, base('webrtc'), base('p2p')), and(Reliable, base('webrtc')), base('webrtc'));
/*
 * Validation funcs
 */ function makeMatchesFunction(partialMatch) {
    function matches(a) {
        let ma;
        try {
            ma = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["multiaddr"])(a);
        } catch (err) {
            return false; // also if it's invalid it's probably not matching as well so return false
        }
        const out = partialMatch(ma.protoNames());
        if (out === null) {
            return false;
        }
        if (out === true || out === false) {
            return out;
        }
        return out.length === 0;
    }
    return matches;
}
function and(...args) {
    function partialMatch(a) {
        if (a.length < args.length) {
            return null;
        }
        let out = a;
        args.some((arg)=>{
            out = typeof arg === 'function' ? arg().partialMatch(a) : arg.partialMatch(a);
            if (Array.isArray(out)) {
                a = out;
            }
            if (out === null) {
                return true;
            }
            return false;
        });
        return out;
    }
    return {
        toString: function() {
            return '{ ' + args.join(' ') + ' }';
        },
        input: args,
        matches: makeMatchesFunction(partialMatch),
        partialMatch
    };
}
function or(...args) {
    function partialMatch(a) {
        let out = null;
        args.some((arg)=>{
            const res = typeof arg === 'function' ? arg().partialMatch(a) : arg.partialMatch(a);
            if (res != null) {
                out = res;
                return true;
            }
            return false;
        });
        return out;
    }
    const result = {
        toString: function() {
            return '{ ' + args.join(' ') + ' }';
        },
        input: args,
        matches: makeMatchesFunction(partialMatch),
        partialMatch
    };
    return result;
}
function base(n) {
    const name = n;
    function matches(a) {
        let ma;
        try {
            ma = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["multiaddr"])(a);
        } catch (err) {
            return false; // also if it's invalid it's probably not matching as well so return false
        }
        const pnames = ma.protoNames();
        if (pnames.length === 1 && pnames[0] === name) {
            return true;
        }
        return false;
    }
    function partialMatch(protos) {
        if (protos.length === 0) {
            return null;
        }
        if (protos[0] === name) {
            return protos.slice(1);
        }
        return null;
    }
    return {
        toString: function() {
            return name;
        },
        matches,
        partialMatch
    };
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/iso-url/src/url-browser.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
const isReactNative = typeof navigator !== 'undefined' && navigator.product === 'ReactNative';
function getDefaultBase() {
    if (isReactNative) {
        return 'http://localhost';
    }
    // in some environments i.e. cloudflare workers location is not available
    if (!self.location) {
        return '';
    }
    return self.location.protocol + '//' + self.location.host;
}
const URL = self.URL;
const defaultBase = getDefaultBase();
class URLWithLegacySupport {
    constructor(url = '', base = defaultBase){
        this.super = new URL(url, base);
        this.path = this.pathname + this.search;
        this.auth = this.username && this.password ? this.username + ':' + this.password : null;
        this.query = this.search && this.search.startsWith('?') ? this.search.slice(1) : null;
    }
    get hash() {
        return this.super.hash;
    }
    get host() {
        return this.super.host;
    }
    get hostname() {
        return this.super.hostname;
    }
    get href() {
        return this.super.href;
    }
    get origin() {
        return this.super.origin;
    }
    get password() {
        return this.super.password;
    }
    get pathname() {
        return this.super.pathname;
    }
    get port() {
        return this.super.port;
    }
    get protocol() {
        return this.super.protocol;
    }
    get search() {
        return this.super.search;
    }
    get searchParams() {
        return this.super.searchParams;
    }
    get username() {
        return this.super.username;
    }
    set hash(hash) {
        this.super.hash = hash;
    }
    set host(host) {
        this.super.host = host;
    }
    set hostname(hostname) {
        this.super.hostname = hostname;
    }
    set href(href) {
        this.super.href = href;
    }
    set password(password) {
        this.super.password = password;
    }
    set pathname(pathname) {
        this.super.pathname = pathname;
    }
    set port(port) {
        this.super.port = port;
    }
    set protocol(protocol) {
        this.super.protocol = protocol;
    }
    set search(search) {
        this.super.search = search;
    }
    set username(username) {
        this.super.username = username;
    }
    /**
   * @param {any} o
   */ static createObjectURL(o) {
        return URL.createObjectURL(o);
    }
    /**
   * @param {string} o
   */ static revokeObjectURL(o) {
        URL.revokeObjectURL(o);
    }
    toJSON() {
        return this.super.toJSON();
    }
    toString() {
        return this.super.toString();
    }
    format() {
        return this.toString();
    }
}
/**
 * @param {string | import('url').UrlObject} obj
 */ function format(obj) {
    if (typeof obj === 'string') {
        const url = new URL(obj);
        return url.toString();
    }
    if (!(obj instanceof URL)) {
        const userPass = // @ts-ignore its not supported in node but we normalise
        obj.username && obj.password ? `${obj.username}:${obj.password}@` : '';
        const auth = obj.auth ? obj.auth + '@' : '';
        const port = obj.port ? ':' + obj.port : '';
        const protocol = obj.protocol ? obj.protocol + '//' : '';
        const host = obj.host || '';
        const hostname = obj.hostname || '';
        const search = obj.search || (obj.query ? '?' + obj.query : '');
        const hash = obj.hash || '';
        const pathname = obj.pathname || '';
        // @ts-ignore - path is not supported in node but we normalise
        const path = obj.path || pathname + search;
        return `${protocol}${userPass || auth}${host || hostname + port}${path}${hash}`;
    }
}
module.exports = {
    URLWithLegacySupport,
    URLSearchParams: self.URLSearchParams,
    defaultBase,
    format
};
}}),
"[project]/node_modules/iso-url/src/relative.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
const { URLWithLegacySupport, format } = __turbopack_require__("[project]/node_modules/iso-url/src/url-browser.js [app-client] (ecmascript)");
/**
 * @param {string | undefined} url
 * @param {any} [location]
 * @param {any} [protocolMap]
 * @param {any} [defaultProtocol]
 */ module.exports = (url, location = {}, protocolMap = {}, defaultProtocol)=>{
    let protocol = location.protocol ? location.protocol.replace(':', '') : 'http';
    // Check protocol map
    protocol = (protocolMap[protocol] || defaultProtocol || protocol) + ':';
    let urlParsed;
    try {
        urlParsed = new URLWithLegacySupport(url);
    } catch (err) {
        urlParsed = {};
    }
    const base = Object.assign({}, location, {
        protocol: protocol || urlParsed.protocol,
        host: location.host || urlParsed.host
    });
    return new URLWithLegacySupport(url, format(base)).toString();
};
}}),
"[project]/node_modules/iso-url/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
const { URLWithLegacySupport, format, URLSearchParams, defaultBase } = __turbopack_require__("[project]/node_modules/iso-url/src/url-browser.js [app-client] (ecmascript)");
const relative = __turbopack_require__("[project]/node_modules/iso-url/src/relative.js [app-client] (ecmascript)");
module.exports = {
    URL: URLWithLegacySupport,
    URLSearchParams,
    format,
    relative,
    defaultBase
};
}}),
"[project]/node_modules/is-ipfs/dist/src/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * @packageDocumentation
 *
 * A suite of util methods that provides efficient validation.
 *
 * Detection of IPFS Paths and identifiers in URLs is a two-stage process:
 *
 * 1. `pathPattern`/`pathGatewayPattern`/`subdomainGatewayPattern` regex is applied to quickly identify potential candidates
 * 2. proper CID validation is applied to remove false-positives
 *
 * @example
 *
 * ```TypeScript
 * import * as isIPFS from 'is-ipfs'
 *
 * isIPFS.multihash('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true
 * isIPFS.multihash('noop') // false
 *
 * isIPFS.cid('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true (CIDv0)
 * isIPFS.cid('bafybeiasb5vpmaounyilfuxbd3lryvosl4yefqrfahsb2esg46q6tu6y5q') // true (CIDv1 in Base32)
 * isIPFS.cid('zdj7WWeQ43G6JJvLWQWZpyHuAMq6uYWRjkBXFad11vE2LHhQ7') // true (CIDv1 in Base58btc)
 * isIPFS.cid('noop') // false
 *
 * isIPFS.base32cid('bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va') // true
 * isIPFS.base32cid('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // false
 *
 * isIPFS.url('https://ipfs.io/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true
 * isIPFS.url('https://ipfs.io/ipfs/QmbWqxBEKC3P8tqsKc98xmWNzrzDtRLMiMPL8wBuTGsMnR?filename=guardian.jpg') // true
 * isIPFS.url('https://ipfs.io/ipns/github.com') // true
 * isIPFS.url('https://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.ipfs.dweb.link') // true
 * isIPFS.url('http://en.wikipedia-on-ipfs.org.ipfs.localhost:8080') // true
 * isIPFS.url('https://github.com/ipfs/js-ipfs/blob/master/README.md') // false
 * isIPFS.url('https://google.com') // false
 *
 * isIPFS.path('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true
 * isIPFS.path('/ipfs/QmbcBPAwCDxRMB1Qe7CRQmxdrTSkxKwM9y6rZw2FjGtbsb/?weird-filename=test.jpg') // true
 * isIPFS.path('/ipns/github.com') // true
 * isIPFS.path('/ipfs/js-ipfs/blob/master/README.md') // false
 *
 * isIPFS.urlOrPath('https://ipfs.io/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true
 * isIPFS.urlOrPath('https://ipfs.io/ipns/github.com') // true
 * isIPFS.urlOrPath('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true
 * isIPFS.urlOrPath('/ipns/github.com') // true
 * isIPFS.urlOrPath('https://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.ipfs.dweb.link') // true
 * isIPFS.urlOrPath('https://google.com') // false
 *
 * isIPFS.ipfsUrl('https://ipfs.io/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true
 * isIPFS.ipfsUrl('https://ipfs.io/ipfs/invalid-hash') // false
 *
 * isIPFS.ipnsUrl('https://ipfs.io/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // false
 * isIPFS.ipnsUrl('https://ipfs.io/ipns/github.com') // true
 *
 * isIPFS.ipfsPath('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true
 * isIPFS.ipfsPath('/ipfs/invalid-hash') // false
 *
 * isIPFS.ipnsPath('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // false
 * isIPFS.ipnsPath('/ipns/github.com') // true
 *
 * isIPFS.cidPath('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o/path/to/file') // true
 * isIPFS.cidPath('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o/') // true
 * isIPFS.cidPath('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // false
 * isIPFS.cidPath('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // false
 * isIPFS.cidPath('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o/file') // false
 *
 * isIPFS.subdomain('http://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.ipfs.dweb.link') // true
 * isIPFS.subdomain('http://bafybeiabc2xofh6tdi6vutusorpumwcikw3hf3st4ecjugo6j52f6xwc6q.ipns.dweb.link') // true
 * isIPFS.subdomain('http://www.bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.ipfs.dweb.link') // false
 * isIPFS.subdomain('http://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.dweb.link') // false
 *
 * isIPFS.ipfsSubdomain('http://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.ipfs.dweb.link') // true
 * isIPFS.ipfsSubdomain('http://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.dweb.link') // false
 *
 * isIPFS.ipnsSubdomain('http://bafybeiabc2xofh6tdi6vutusorpumwcikw3hf3st4ecjugo6j52f6xwc6q.ipns.dweb.link') // true
 * isIPFS.ipnsSubdomain('http://bafybeiabc2xofh6tdi6vutusorpumwcikw3hf3st4ecjugo6j52f6xwc6q.dweb.link') // false
 * isIPFS.ipnsSubdomain('http://QmcNioXSC1bfJj1dcFErhUfyjFzoX2HodkRccsFFVJJvg8.ipns.dweb.link') // false
 * isIPFS.ipnsSubdomain('http://en.wikipedia-on-ipfs.org.ipns.localhost:8080') // true (assuming DNSLink)
 * isIPFS.ipnsSubdomain('http://en-wikipedia--on--ipfs-org.ipns.localhost:8080') // true (assuming inlined DNSLink)
 * isIPFS.ipnsSubdomain('http://hostname-without-tld-.ipns.dweb.link') // false (not a CID, invalid DNS label)
 *
 * isIPFS.multiaddr('/ip4/127.0.0.1/udp/1234') // true
 * isIPFS.multiaddr('/ip4/127.0.0.1/udp/1234/http') // true
 * isIPFS.multiaddr('/ip6/::1/udp/1234') // true
 * isIPFS.multiaddr('ip6/::1/udp/1234') // false
 * isIPFS.multiaddr('/yoloinvalid/::1/udp/1234') // false
 *
 * isIPFS.peerMultiaddr('/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSoooo4') // true
 * isIPFS.peerMultiaddr('/ipfs/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSoooo4') // true (legacy notation)
 * isIPFS.peerMultiaddr('/ip4/127.0.0.1/tcp/1234/ws/p2p/QmUjNmr8TgJCn1Ao7DvMy4cjoZU15b9bwSCBLE3vwXiwgj') // true
 * isIPFS.peerMultiaddr('/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSoooo4/p2p-circuit/p2p/QmUjNmr8TgJCn1Ao7DvMy4cjoZU15b9bwSCBLE3vwXiwgj') // true
 * isIPFS.peerMultiaddr('/dnsaddr/bootstrap.libp2p.io') // false (key missing, needs additional DNS lookup to tell if this is valid)
 * isIPFS.peerMultiaddr('/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN') // true (key present, ip and port can be resolved later)
 * isIPFS.peerMultiaddr('/ip4/127.0.0.1/udp/1234') // false (key missing)
 * ```
 */ __turbopack_esm__({
    "base32cid": (()=>base32cid),
    "cid": (()=>isCID),
    "cidPath": (()=>cidPath),
    "ipfsPath": (()=>ipfsPath),
    "ipfsSubdomain": (()=>ipfsSubdomain),
    "ipfsUrl": (()=>ipfsUrl),
    "ipnsPath": (()=>ipnsPath),
    "ipnsSubdomain": (()=>ipnsSubdomain),
    "ipnsUrl": (()=>ipnsUrl),
    "multiaddr": (()=>isMultiaddr),
    "multihash": (()=>isMultihash),
    "path": (()=>path),
    "pathGatewayPattern": (()=>pathGatewayPattern),
    "pathPattern": (()=>pathPattern),
    "peerMultiaddr": (()=>isPeerMultiaddr),
    "subdomain": (()=>subdomain),
    "subdomainGatewayPattern": (()=>subdomainGatewayPattern),
    "url": (()=>url),
    "urlOrPath": (()=>urlOrPath)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$mafmt$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@multiformats/mafmt/dist/src/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@multiformats/multiaddr/dist/src/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$iso$2d$url$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/iso-url/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/base32.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/bases/base58.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/cid.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/hashes/digest.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/uint8arrays/dist/src/to-string.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@multiformats/multiaddr/dist/src/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/multiformats/dist/src/cid.js [app-client] (ecmascript) <locals>");
;
;
;
;
;
;
;
;
const pathGatewayPattern = /^https?:\/\/[^/]+\/(ip[fn]s)\/([^/?#]+)/;
const pathPattern = /^\/(ip[fn]s)\/([^/?#]+)/;
const defaultProtocolMatch = 1;
const defaultHashMath = 2;
const subdomainGatewayPattern = /^https?:\/\/([^/]+)\.(ip[fn]s)\.[^/?]+/;
const subdomainIdMatch = 1;
const subdomainProtocolMatch = 2;
// Fully qualified domain name (FQDN) that has an explicit .tld suffix
const fqdnWithTld = /^(([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])\.)+([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])$/;
function isMultihash(hash) {
    const formatted = convertToString(hash);
    if (formatted === false) {
        return false;
    }
    try {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.decode(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base58btc"].decode(`z${formatted}`));
    } catch  {
        return false;
    }
    return true;
}
function isMultiaddr(input) {
    try {
        return Boolean((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$multiaddr$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["multiaddr"])(input));
    } catch  {
        return false;
    }
}
function isBase32EncodedMultibase(hash) {
    try {
        let cid;
        if (isString(hash)) {
            cid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].parse(hash);
        } else {
            cid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].asCID(hash);
        }
        if (cid == null) {
            return false;
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base32"].decode(cid.toString());
    } catch  {
        return false;
    }
    return true;
}
function isCID(hash) {
    try {
        if (isString(hash)) {
            return Boolean(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].parse(hash));
        }
        if (hash instanceof Uint8Array) {
            return Boolean(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].decode(hash));
        }
        return Boolean(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].asCID(hash)); // eslint-disable-line no-new
    } catch  {
        return false;
    }
}
/**
 * @param {string | Uint8Array | Multiaddr} input
 */ function isPeerMultiaddr(input) {
    return isMultiaddr(input) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$mafmt$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.P2P.matches(input);
}
/**
 * @param {string | Uint8Array} input
 * @param {RegExp | string} pattern
 * @param {number} [protocolMatch=1]
 * @param {number} [hashMatch=2]
 */ function isIpfs(input, pattern, protocolMatch = defaultProtocolMatch, hashMatch = defaultHashMath) {
    const formatted = convertToString(input);
    if (formatted === false) {
        return false;
    }
    const match = formatted.match(pattern);
    if (match == null) {
        return false;
    }
    if (match[protocolMatch] !== 'ipfs') {
        return false;
    }
    let hash = match[hashMatch];
    if (hash != null && pattern === subdomainGatewayPattern) {
        // when doing checks for subdomain context
        // ensure hash is case-insensitive
        // (browsers force-lowercase authority component anyway)
        hash = hash.toLowerCase();
    }
    return isCID(hash);
}
/**
 *
 * @param {string | Uint8Array} input
 * @param {string | RegExp} pattern
 * @param {number} [protocolMatch=1]
 * @param {number} [hashMatch=1]
 */ function isIpns(input, pattern, protocolMatch = defaultProtocolMatch, hashMatch = defaultHashMath) {
    const formatted = convertToString(input);
    if (formatted === false) {
        return false;
    }
    const match = formatted.match(pattern);
    if (match == null) {
        return false;
    }
    if (match[protocolMatch] !== 'ipns') {
        return false;
    }
    let ipnsId = match[hashMatch];
    if (ipnsId != null && pattern === subdomainGatewayPattern) {
        // when doing checks for subdomain context
        // ensure ipnsId is case-insensitive
        // (browsers force-lowercase authority compotent anyway)
        ipnsId = ipnsId.toLowerCase();
        // Check if it is cidv1
        if (isCID(ipnsId)) return true;
        // Check if it looks like FQDN
        try {
            if (!ipnsId.includes('.') && ipnsId.includes('-')) {
                // name without tld, assuming its inlined into a single DNS label
                // (https://github.com/ipfs/in-web-browsers/issues/169)
                // en-wikipedia--on--ipfs-org  en.wikipedia-on-ipfs.org
                ipnsId = ipnsId.replace(/--/g, '@').replace(/-/g, '.').replace(/@/g, '-');
            }
            // URL implementation in web browsers forces lowercase of the hostname
            const { hostname } = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$iso$2d$url$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["URL"](`http://${ipnsId}`); // eslint-disable-line no-new
            // Check if potential FQDN has an explicit TLD
            return fqdnWithTld.test(hostname);
        } catch (e) {
            return false;
        }
    }
    return true;
}
/**
 * @param {any} input
 */ function isString(input) {
    return typeof input === 'string';
}
/**
 * @param {Uint8Array | string} input
 */ function convertToString(input) {
    if (input instanceof Uint8Array) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toString"])(input, 'base58btc');
    }
    if (isString(input)) {
        return input;
    }
    return false;
}
const ipfsSubdomain = (url)=>isIpfs(url, subdomainGatewayPattern, subdomainProtocolMatch, subdomainIdMatch);
const ipnsSubdomain = (url)=>isIpns(url, subdomainGatewayPattern, subdomainProtocolMatch, subdomainIdMatch);
const subdomain = (url)=>ipfsSubdomain(url) || ipnsSubdomain(url);
const ipfsUrl = (url)=>isIpfs(url, pathGatewayPattern) || ipfsSubdomain(url);
const ipnsUrl = (url)=>isIpns(url, pathGatewayPattern) || ipnsSubdomain(url);
const url = (url)=>ipfsUrl(url) || ipnsUrl(url) || subdomain(url);
const path = (path)=>isIpfs(path, pathPattern) || isIpns(path, pathPattern);
;
;
;
;
const base32cid = (cid)=>isCID(cid) && isBase32EncodedMultibase(cid);
const ipfsPath = (path)=>isIpfs(path, pathPattern);
const ipnsPath = (path)=>isIpns(path, pathPattern);
const urlOrPath = (x)=>url(x) || path(x);
const cidPath = (path)=>isString(path) && !isCID(path) && isIpfs(`/ipfs/${path}`, pathPattern); //# sourceMappingURL=index.js.map
}}),
}]);

//# sourceMappingURL=node_modules_264a02._.js.map