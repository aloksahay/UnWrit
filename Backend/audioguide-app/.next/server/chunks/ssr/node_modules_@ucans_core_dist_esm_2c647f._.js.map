{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"util.js","sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/node_modules/%40ucans/core/dist/src/util.ts"],"sourcesContent":["const CHARS = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\n\nexport const generateNonce = (len = 6): string => {\n  let nonce = \"\"\n  for (let i = 0; i < len; i++) {\n    nonce += CHARS[ Math.floor(Math.random() * CHARS.length) ]\n  }\n  return nonce\n}\n\nexport function hasProp<K extends PropertyKey>(data: unknown, prop: K): data is Record<K, unknown> {\n  return typeof data === \"object\" && data != null && prop in data\n}\n\nexport function isRecord(data: unknown): data is Record<PropertyKey, unknown> {\n  return typeof data === \"object\" && data != null\n}\n\nexport function isIterable<T>(obj: unknown): obj is Iterable<T> {\n  return typeof obj === \"object\" && obj != null && Symbol.iterator in obj\n}\n\nexport function isAsyncIterable<T>(obj: unknown): obj is AsyncIterable<T> {\n  return typeof obj === \"object\" && obj != null && Symbol.asyncIterator in obj\n}\n\n\nexport function all<T>(it: Iterable<T>): T[]\nexport function all<T>(it: AsyncIterable<T>): Promise<T[]>\nexport function all<T>(it: Iterable<T> | AsyncIterable<T>): T[] | Promise<T[]> {\n  if (isIterable(it)) {\n    const arr = []\n    for (const elem of it) {\n      arr.push(elem)\n    }\n    return arr\n  } else if (isAsyncIterable(it)) {\n    return (async () => {\n      const arr = []\n      for await (const elem of it) {\n        arr.push(elem)\n      }\n      return arr\n    })()\n  } else {\n    throw new TypeError(`Expected either Iterable or AsyncIterable, but got ${it}`)\n  }\n}\n\nexport function first<T>(it: Iterable<T>): T | undefined\nexport function first<T>(it: AsyncIterable<T>): Promise<T | undefined>\nexport function first<T>(it: Iterable<T> | AsyncIterable<T>): T | undefined | Promise<T | undefined> {\n  if (isIterable(it)) {\n    for (const elem of it) {\n      return elem\n    }\n    return undefined\n  } else if (isAsyncIterable(it)) {\n    return (async () => {\n      for await (const elem of it) {\n        return elem\n      }\n      return undefined\n    })()\n  } else {\n    throw new TypeError(`Expected either Iterable or AsyncIterable, but got ${it}`)\n  }\n}\n\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAM,KAAK,GAAG,gEAAgE,CAAA;AAGvE,MAAM,aAAa,GAAG,CAAC,GAAG,GAAG,CAAC,EAAU,EAAE;IAC/C,IAAI,KAAK,GAAG,EAAE,CAAA;IACd,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,CAAE;QAC5B,KAAK,IAAI,KAAK,CAAE,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,KAAK,CAAC,MAAM,CAAC,CAAE,CAAA;KAC3D;IACD,OAAO,KAAK,CAAA;AACd,CAAC,CAAA;AAEK,SAAU,OAAO,CAAwB,IAAa,EAAE,IAAO;IACnE,OAAO,OAAO,IAAI,KAAK,QAAQ,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,CAAA;AACjE,CAAC;AAEK,SAAU,QAAQ,CAAC,IAAa;IACpC,OAAO,OAAO,IAAI,KAAK,QAAQ,IAAI,IAAI,IAAI,IAAI,CAAA;AACjD,CAAC;AAEK,SAAU,UAAU,CAAI,GAAY;IACxC,OAAO,OAAO,GAAG,KAAK,QAAQ,IAAI,GAAG,IAAI,IAAI,IAAI,MAAM,CAAC,QAAQ,IAAI,GAAG,CAAA;AACzE,CAAC;AAEK,SAAU,eAAe,CAAI,GAAY;IAC7C,OAAO,OAAO,GAAG,KAAK,QAAQ,IAAI,GAAG,IAAI,IAAI,IAAI,MAAM,CAAC,aAAa,IAAI,GAAG,CAAA;AAC9E,CAAC;AAKK,SAAU,GAAG,CAAI,EAAkC;IACvD,IAAI,UAAU,CAAC,EAAE,CAAC,EAAE;QAClB,MAAM,GAAG,GAAG,EAAE,CAAA;QACd,KAAK,MAAM,IAAI,IAAI,EAAE,CAAE;YACrB,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;SACf;QACD,OAAO,GAAG,CAAA;KACX,MAAM,IAAI,eAAe,CAAC,EAAE,CAAC,EAAE;QAC9B,OAAO,CAAC,GAAS,CAAE,CAAA,SAAA,IAAA,EAAA,KAAA,GAAA,KAAA,GAAA;;gBACjB,MAAM,GAAG,GAAG,EAAE,CAAA;;oBACd,IAAyB,IAAA,OAAA,cAAA,EAAE,CAAA,EAAA,MAAA,EAAA,SAAA,MAAA,KAAA,IAAA,IAAA,CAAA,OAAA,IAAA,EAAA;wBAAhB,MAAM,IAAI,GAAA,OAAA,KAAA,CAAA;wBACnB,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;qBACf;;;;;;;;;;;;gBACD,OAAO,GAAG,CAAA;YACZ,CAAC,CAAA,CAAC,EAAE,CAAA;KACL,MAAM;QACL,MAAM,IAAI,SAAS,CAAC,CAAA,mDAAA,EAAsD,EAAE,EAAE,CAAC,CAAA;KAChF;AACH,CAAC;AAIK,SAAU,KAAK,CAAI,EAAkC;IACzD,IAAI,UAAU,CAAC,EAAE,CAAC,EAAE;QAClB,KAAK,MAAM,IAAI,IAAI,EAAE,CAAE;YACrB,OAAO,IAAI,CAAA;SACZ;QACD,OAAO,SAAS,CAAA;KACjB,MAAM,IAAI,eAAe,CAAC,EAAE,CAAC,EAAE;QAC9B,OAAO,CAAC,GAAS,CAAE,CAAA,SAAA,IAAA,EAAA,KAAA,GAAA,KAAA,GAAA;;;oBACjB,IAAyB,IAAA,OAAA,cAAA,EAAE,CAAA,EAAA,MAAA,EAAA,SAAA,MAAA,KAAA,IAAA,IAAA,CAAA,OAAA,IAAA,EAAA;wBAAhB,MAAM,IAAI,GAAA,OAAA,KAAA,CAAA;wBACnB,OAAO,IAAI,CAAA;qBACZ;;;;;;;;;;;;gBACD,OAAO,SAAS,CAAA;YAClB,CAAC,CAAA,CAAC,EAAE,CAAA;KACL,MAAM;QACL,MAAM,IAAI,SAAS,CAAC,CAAA,mDAAA,EAAsD,EAAE,EAAE,CAAC,CAAA;KAChF;AACH,CAAC","ignoreList":[0]}},
    {"offset": {"line": 150, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 156, "column": 0}, "map": {"version":3,"file":"semver.js","sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/node_modules/%40ucans/core/dist/src/semver.ts"],"sourcesContent":["import { hasProp, isRecord } from \"./util.js\"\n\n\n// Types\n\nexport interface SemVer {\n  major: number\n  minor: number\n  patch: number\n}\n\nexport function isSemVer(obj: unknown): obj is SemVer {\n  return isRecord(obj)\n    && hasProp(obj, \"major\") && typeof obj.major === \"number\"\n    && hasProp(obj, \"minor\") && typeof obj.minor === \"number\"\n    && hasProp(obj, \"patch\") && typeof obj.patch === \"number\"\n}\n\n\n// Parsing\n\nconst NUM_REGEX = /^0|[1-9]\\d*/\n\nconst matchesRegex = (regex: RegExp) => (str: string) => {\n  const m = str.match(regex)\n  if (!m) return false\n  return m[0].length === str.length\n}\n\nexport function parse(version: string): SemVer | null {\n  const sv = version.match(\n    /^(?<major>0|[1-9]\\d*)\\.(?<minor>0|[1-9]\\d*)\\.(?<patch>0|[1-9]\\d*)(?:-(?<prerelease>(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+(?<buildmetadata>[0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$/\n  )\n\n  if (sv === null) {\n    return null\n  }\n\n  const parts =\n    `${sv.groups?.major}.${sv.groups?.minor}.${sv.groups?.patch}`.split(\".\")\n\n  if (parts.length !== 3) {\n    return null\n  }\n\n  if (!parts.every(matchesRegex(NUM_REGEX))) {\n    return null\n  }\n\n  const [major, minor, patch] = parts.map(part => parseInt(part, 10))\n\n  if (!Number.isSafeInteger(major) || !Number.isSafeInteger(minor) || !Number.isSafeInteger(patch)) {\n    return null\n  }\n  if (major < 0 || minor < 0 || patch < 0) {\n    return null\n  }\n\n  return { major, minor, patch }\n}\n\n\n// Formatting/Prettyprinting\n\nexport function format(semver: SemVer): string {\n  return `${semver.major}.${semver.minor}.${semver.patch}`\n}\n\n\n// Comparison\n\nexport const GT = 1\nexport const EQ = 0\nexport const LT = -1\nexport type GT = typeof GT\nexport type EQ = typeof EQ\nexport type LT = typeof LT\n\nfunction comparePart(left?: number, right?: number): GT | EQ | LT {\n  // when at least one of them is null\n  if (left == null) {\n    if (right == null) return EQ\n    return LT\n  } else if (right == null) {\n    return GT\n  }\n\n  // when none of them are null\n  if (left > right) return GT\n  if (left < right) return LT\n  return EQ\n}\n\nexport function compare(left: SemVer | string, right: SemVer | string): GT | EQ | LT {\n  const l = typeof left === \"string\" ? parse(left) : left\n  const r = typeof right === \"string\" ? parse(right) : right\n  return (\n    comparePart(l?.major, r?.major) ||\n    comparePart(l?.minor, r?.minor) ||\n    comparePart(l?.patch, r?.patch)\n  )\n}\n\nexport function lt(left: SemVer | string, right: SemVer | string): boolean {\n  return compare(left, right) === LT\n}\n\nexport function gte(left: SemVer | string, right: SemVer | string): boolean {\n  return !lt(left, right)\n}\n\nexport function gt(left: SemVer | string, right: SemVer | string): boolean {\n  return compare(left, right) === GT\n}\n\nexport function lte(left: SemVer | string, right: SemVer | string): boolean {\n  return !gt(left, right)\n}\n\nexport function eq(left: SemVer | string, right: SemVer | string): boolean {\n  return compare(left, right) === EQ\n}\n\nexport function neq(left: SemVer | string, right: SemVer | string): boolean {\n  return !eq(left, right)\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 251, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 257, "column": 0}, "map": {"version":3,"file":"super-user.js","sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/node_modules/%40ucans/core/dist/src/capability/super-user.ts"],"sourcesContent":["export const SUPERUSER: Superuser = \"*\"\nexport type Superuser = \"*\" // maximum ability\n\n\n// TYPE CHECKS\n\n\nexport function isSuperuser(obj: unknown): obj is Superuser {\n  return obj === SUPERUSER\n}"],"names":[],"mappings":";;;;AAAO,MAAM,SAAS,GAAc,GAAG,CAAA;AAOjC,SAAU,WAAW,CAAC,GAAY;IACtC,OAAO,GAAG,KAAK,SAAS,CAAA;AAC1B,CAAC","ignoreList":[0]}},
    {"offset": {"line": 265, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 271, "column": 0}, "map": {"version":3,"file":"ability.js","sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/node_modules/%40ucans/core/dist/src/capability/ability.ts"],"sourcesContent":["import { Superuser, SUPERUSER } from \"./super-user.js\"\nimport * as util from \"../util.js\"\n\n// RE-EXPORTS\n\n\nexport { Superuser, SUPERUSER }\n\n\n// ðŸ’Ž\n\n\nexport type Ability\n  = Superuser\n  | { namespace: string; segments: string[] }\n\n\n/**\n * Separator for an ability's segments.\n */\nexport const SEPARATOR: string = \"/\"\n\n\n/**\n * Ability that can be used with a `prf` resource-pointer.\n * This redelegates all capabilities of the proof(s).\n */\nexport const REDELEGATE: Ability = { namespace: \"ucan\", segments: [ \"DELEGATE\" ] }\n\n\n\n// TYPE CHECKS\n\n\nexport function isAbility(obj: unknown): obj is Ability {\n  return obj === SUPERUSER\n    || (\n      util.isRecord(obj)\n      && util.hasProp(obj, \"namespace\") && typeof obj.namespace === \"string\"\n      && util.hasProp(obj, \"segments\") && Array.isArray(obj.segments) && obj.segments.every(s => typeof s === \"string\")\n    )\n}\n\n\n\n// ðŸ› \n\n\nexport function isEqual(a: Ability, b: Ability): boolean {\n  if (a === SUPERUSER && b === SUPERUSER) return true\n  if (a === SUPERUSER || b === SUPERUSER) return false\n\n  return (\n    a.namespace.toLowerCase() ===\n    b.namespace.toLowerCase()\n  ) &&\n    (\n      joinSegments(a.segments).toLowerCase() ===\n      joinSegments(b.segments).toLowerCase()\n    )\n}\n\n\nexport function joinSegments(segments: string[]): string {\n  return segments.join(SEPARATOR)\n}\n\n\n\n// ENCODING\n\n\n/**\n * Encode an ability.\n *\n * @param ability The ability to encode\n */\nexport function encode(ability: Ability): string {\n  switch (ability) {\n    case SUPERUSER: return ability\n    default: return joinSegments([ ability.namespace, ...ability.segments ])\n  }\n}\n\n/**\n * Parse an encoded ability.\n *\n * @param ability The encoded ability\n */\nexport function parse(ability: string): Ability {\n  switch (ability) {\n    case SUPERUSER:\n      return SUPERUSER\n    default: {\n      const [ namespace, ...segments ] = ability.split(SEPARATOR)\n      return { namespace, segments }\n    }\n  }\n}"],"names":[],"mappings":";;;;;;;;;AAAA,OAAO,EAAa,SAAS,EAAE,MAAM,iBAAiB,CAAA;AACtD,OAAO,KAAK,IAAI,MAAM,YAAY,CAAA;;;;AAmB3B,MAAM,SAAS,GAAW,GAAG,CAAA;AAO7B,MAAM,UAAU,GAAY;IAAE,SAAS,EAAE,MAAM;IAAE,QAAQ,EAAE;QAAE,UAAU;KAAE;AAAA,CAAE,CAAA;AAO5E,SAAU,SAAS,CAAC,GAAY;IACpC,OAAO,GAAG,mLAAK,YAAS,IAEpB,IAAI,mJAAC,QAAQ,CAAC,GAAG,CAAC,IACf,IAAI,mJAAC,OAAO,CAAC,GAAG,EAAE,WAAW,CAAC,IAAI,OAAO,GAAG,CAAC,SAAS,KAAK,QAAQ,IACnE,IAAI,mJAAC,OAAO,CAAC,GAAG,EAAE,UAAU,CAAC,IAAI,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,IAAI,GAAG,CAAC,QAAQ,CAAC,KAAK,EAAC,CAAC,CAAC,EAAE,AAAC,OAAO,CAAC,KAAK,QAAQ,CAAC,CAClH,CAAA;AACL,CAAC;AAOK,SAAU,OAAO,CAAC,CAAU,EAAE,CAAU;IAC5C,IAAI,CAAC,mLAAK,YAAS,IAAI,CAAC,mLAAK,YAAS,EAAE,OAAO,IAAI,CAAA;IACnD,IAAI,CAAC,mLAAK,YAAS,IAAI,CAAC,mLAAK,YAAS,EAAE,OAAO,KAAK,CAAA;IAEpD,OAAO,AACL,CAAC,CAAC,SAAS,CAAC,WAAW,EAAE,KACzB,CAAC,CAAC,SAAS,CAAC,WAAW,EAAE,CAC1B,GAEG,YAAY,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,WAAW,EAAE,KACtC,YAAY,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,WAAW,EAAE,CACvC,CAAA;AACL,CAAC;AAGK,SAAU,YAAY,CAAC,QAAkB;IAC7C,OAAO,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,CAAA;AACjC,CAAC;AAYK,SAAU,MAAM,CAAC,OAAgB;IACrC,OAAQ,OAAO,EAAE;QACf,mLAAK,YAAS,CAAC;YAAC,OAAO,OAAO,CAAA;QAC9B,OAAO,CAAC;YAAC,OAAO,YAAY,CAAC;gBAAE,OAAO,CAAC,SAAS,EAAE;mBAAG,OAAO,CAAC,QAAQ;aAAE,CAAC,CAAA;KACzE;AACH,CAAC;AAOK,SAAU,KAAK,CAAC,OAAe;IACnC,OAAQ,OAAO,EAAE;QACf,mLAAK,YAAS;YACZ,qLAAO,YAAS,CAAA;QAClB,OAAO,CAAC;YAAC;gBACP,MAAM,CAAE,SAAS,EAAE,GAAG,QAAQ,CAAE,GAAG,OAAO,CAAC,KAAK,CAAC,SAAS,CAAC,CAAA;gBAC3D,OAAO;oBAAE,SAAS;oBAAE,QAAQ;gBAAA,CAAE,CAAA;aAC/B;KACF;AACH,CAAC","ignoreList":[0]}},
    {"offset": {"line": 328, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 344, "column": 0}, "map": {"version":3,"file":"resource-pointer.js","sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/node_modules/%40ucans/core/dist/src/capability/resource-pointer.ts"],"sourcesContent":["import { Superuser, SUPERUSER } from \"./super-user.js\"\nimport * as util from \"../util.js\"\n\n\n// ðŸ’Ž\n\n\nexport type ResourcePointer = {\n  scheme: string\n  hierPart: Superuser | string\n}\n\n\n/**\n * Separator for pieces of a URI.\n */\nexport const SEPARATOR: string = \":\"\n\n\n\n// TYPE CHECKS\n\n\nexport function isResourcePointer(obj: unknown): obj is ResourcePointer {\n  return util.isRecord(obj)\n    && util.hasProp(obj, \"scheme\") && typeof obj.scheme === \"string\"\n    && util.hasProp(obj, \"hierPart\") && (obj.hierPart === SUPERUSER || typeof obj.hierPart === \"string\")\n}\n\n\n\n// ðŸŒ¸\n\n\nexport function as(did: string, resource: Superuser | string): ResourcePointer {\n  return {\n    scheme: \"as\",\n    hierPart: `${did}:${resource}`\n  }\n}\n\n\nexport function my(resource: Superuser | string): ResourcePointer {\n  return {\n    scheme: \"my\",\n    hierPart: resource\n  }\n}\n\n\nexport function prf(selector: Superuser | number): ResourcePointer {\n  return {\n    scheme: \"prf\",\n    hierPart: selector.toString()\n  }\n}\n\n\n\n// ðŸ› \n\n\nexport function isEqual(a: ResourcePointer, b: ResourcePointer): boolean {\n  return a.scheme.toLowerCase() === a.scheme.toLowerCase() && a.hierPart === b.hierPart\n}\n\n\n\n// ENCODING\n\n\n/**\n * Encode a resource pointer.\n *\n * @param pointer The resource pointer to encode\n */\nexport function encode(pointer: ResourcePointer): string {\n  return `${pointer.scheme}${SEPARATOR}${pointer.hierPart}`\n}\n\n/**\n * Parse an encoded resource pointer.\n *\n * @param pointer The encoded resource pointer\n */\nexport function parse(pointer: string): ResourcePointer {\n  const [ scheme, ...hierPart ] = pointer.split(SEPARATOR)\n  return { scheme, hierPart: hierPart.join(SEPARATOR) }\n}"],"names":[],"mappings":";;;;;;;;;;AAAA,OAAO,EAAa,SAAS,EAAE,MAAM,iBAAiB,CAAA;AACtD,OAAO,KAAK,IAAI,MAAM,YAAY,CAAA;;;AAe3B,MAAM,SAAS,GAAW,GAAG,CAAA;AAO9B,SAAU,iBAAiB,CAAC,GAAY;IAC5C,OAAO,IAAI,mJAAC,QAAQ,CAAC,GAAG,CAAC,IACpB,IAAI,mJAAC,OAAO,CAAC,GAAG,EAAE,QAAQ,CAAC,IAAI,OAAO,GAAG,CAAC,MAAM,KAAK,QAAQ,IAC7D,IAAI,mJAAC,OAAO,CAAC,GAAG,EAAE,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,QAAQ,mLAAK,YAAS,IAAI,OAAO,GAAG,CAAC,QAAQ,KAAK,QAAQ,CAAC,CAAA;AACxG,CAAC;AAOK,SAAU,EAAE,CAAC,GAAW,EAAE,QAA4B;IAC1D,OAAO;QACL,MAAM,EAAE,IAAI;QACZ,QAAQ,EAAE,GAAG,GAAG,CAAA,CAAA,EAAI,QAAQ,EAAE;KAC/B,CAAA;AACH,CAAC;AAGK,SAAU,EAAE,CAAC,QAA4B;IAC7C,OAAO;QACL,MAAM,EAAE,IAAI;QACZ,QAAQ,EAAE,QAAQ;KACnB,CAAA;AACH,CAAC;AAGK,SAAU,GAAG,CAAC,QAA4B;IAC9C,OAAO;QACL,MAAM,EAAE,KAAK;QACb,QAAQ,EAAE,QAAQ,CAAC,QAAQ,EAAE;KAC9B,CAAA;AACH,CAAC;AAOK,SAAU,OAAO,CAAC,CAAkB,EAAE,CAAkB;IAC5D,OAAO,CAAC,CAAC,MAAM,CAAC,WAAW,EAAE,KAAK,CAAC,CAAC,MAAM,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC,QAAQ,KAAK,CAAC,CAAC,QAAQ,CAAA;AACvF,CAAC;AAYK,SAAU,MAAM,CAAC,OAAwB;IAC7C,OAAO,GAAG,OAAO,CAAC,MAAM,GAAG,SAAS,GAAG,OAAO,CAAC,QAAQ,EAAE,CAAA;AAC3D,CAAC;AAOK,SAAU,KAAK,CAAC,OAAe;IACnC,MAAM,CAAE,MAAM,EAAE,GAAG,QAAQ,CAAE,GAAG,OAAO,CAAC,KAAK,CAAC,SAAS,CAAC,CAAA;IACxD,OAAO;QAAE,MAAM;QAAE,QAAQ,EAAE,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC;IAAA,CAAE,CAAA;AACvD,CAAC","ignoreList":[0]}},
    {"offset": {"line": 393, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 435, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/node_modules/%40ucans/core/dist/src/capability/index.ts"],"sourcesContent":["import * as ability from \"./ability.js\"\nimport * as resourcePointer from \"./resource-pointer.js\"\nimport * as util from \"../util.js\"\n\nimport { Ability, isAbility } from \"./ability.js\"\nimport { ResourcePointer, isResourcePointer } from \"./resource-pointer.js\"\nimport { Superuser } from \"./super-user.js\"\n\n\n// RE-EXPORTS\n\n\nexport { ability, resourcePointer, Ability, isAbility }\n\n\n\n// ðŸ’Ž\n\n\nexport type Capability = {\n  with: ResourcePointer\n  can: Ability\n}\n\nexport type EncodedCapability = {\n  with: string\n  can: string\n}\n\n\n\n// TYPE CHECKS\n\n\nexport function isCapability(obj: unknown): obj is Capability {\n  return util.isRecord(obj)\n    && util.hasProp(obj, \"with\") && isResourcePointer(obj.with)\n    && util.hasProp(obj, \"can\") && isAbility(obj.can)\n}\n\nexport function isEncodedCapability(obj: unknown): obj is EncodedCapability {\n  return util.isRecord(obj)\n    && util.hasProp(obj, \"with\") && typeof obj.with === \"string\"\n    && util.hasProp(obj, \"can\") && typeof obj.can === \"string\"\n}\n\n\n\n// ðŸŒ¸\n\n\nexport function as(did: string, resource: Superuser | string): Capability {\n  return {\n    with: resourcePointer.as(did, resource),\n    can: ability.SUPERUSER\n  }\n}\n\n\nexport function my(resource: Superuser | string): Capability {\n  return {\n    with: resourcePointer.my(resource),\n    can: ability.SUPERUSER\n  }\n}\n\n\nexport function prf(selector: Superuser | number, ability: Ability): Capability {\n  return {\n    with: resourcePointer.prf(selector),\n    can: ability\n  }\n}\n\n\n\n// ðŸ› \n\n\n/**\n * Check if two capabilities are equal.\n *\n * This is not the same as `JSON.stringify(capA) === JSON.stringify(capB)`.\n * Specifically:\n *   - For resource pointers, it does case-insensitive matching of the `scheme`.\n *   - For abilities, it does case-insensitive matching of the namespace and segments.\n */\nexport function isEqual(a: Capability, b: Capability): boolean {\n  return resourcePointer.isEqual(a.with, b.with) && ability.isEqual(a.can, b.can)\n}\n\n\n\n// ENCODING\n\n\n/**\n * Encode the individual parts of a capability.\n *\n * @param cap The capability to encode\n */\nexport function encode(cap: Capability): EncodedCapability {\n  return {\n    with: resourcePointer.encode(cap.with),\n    can: ability.encode(cap.can)\n  }\n}\n\n/**\n * Parse an encoded capability.\n *\n * @param cap The encoded capability\n */\nexport function parse(cap: EncodedCapability): Capability {\n  return {\n    with: resourcePointer.parse(cap.with),\n    can: ability.parse(cap.can)\n  }\n}"],"names":[],"mappings":";;;;;;;;;;AAEA,OAAO,KAAK,IAAI,MAAM,YAAY,CAAA;AAGlC,OAAO,EAAmB,iBAAiB,EAAE,MAAM,uBAAuB,CAAA;AAD1E,OAAO,EAAW,SAAS,EAAE,MAAM,cAAc,CAAA;AAJjD,OAAO,KAAK,OAAO,MAAM,cAAc,CAAA;;;;;;;AAkCjC,SAAU,YAAY,CAAC,GAAY;IACvC,OAAO,IAAI,mJAAC,QAAQ,CAAC,GAAG,CAAC,IACpB,IAAI,mJAAC,OAAO,CAAC,GAAG,EAAE,MAAM,CAAC,4LAAI,oBAAiB,AAAjB,EAAkB,GAAG,CAAC,IAAI,CAAC,IACxD,IAAI,mJAAC,OAAO,CAAC,GAAG,EAAE,KAAK,CAAC,gMAAI,YAAA,AAAS,EAAC,GAAG,CAAC,GAAG,CAAC,CAAA;AACrD,CAAC;AAEK,SAAU,mBAAmB,CAAC,GAAY;IAC9C,OAAO,IAAI,mJAAC,QAAQ,CAAC,GAAG,CAAC,IACpB,IAAI,mJAAC,OAAO,CAAC,GAAG,EAAE,MAAM,CAAC,IAAI,OAAO,GAAG,CAAC,IAAI,KAAK,QAAQ,IACzD,IAAI,mJAAC,OAAO,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,OAAO,GAAG,CAAC,GAAG,KAAK,QAAQ,CAAA;AAC9D,CAAC;AAOK,SAAU,EAAE,CAAC,GAAW,EAAE,QAA4B;IAC1D,OAAO;QACL,IAAI,EAAE,eAAe,qKAAC,EAAE,CAAC,GAAG,EAAE,QAAQ,CAAC;QACvC,GAAG,EAAE,OAAO,iKAAC,SAAS;KACvB,CAAA;AACH,CAAC;AAGK,SAAU,EAAE,CAAC,QAA4B;IAC7C,OAAO;QACL,IAAI,EAAE,eAAe,qKAAC,EAAE,CAAC,QAAQ,CAAC;QAClC,GAAG,EAAE,OAAO,iKAAC,SAAS;KACvB,CAAA;AACH,CAAC;AAGK,SAAU,GAAG,CAAC,QAA4B,EAAE,OAAgB;IAChE,OAAO;QACL,IAAI,EAAE,eAAe,qKAAC,GAAG,CAAC,QAAQ,CAAC;QACnC,GAAG,EAAE,OAAO;KACb,CAAA;AACH,CAAC;AAeK,SAAU,OAAO,CAAC,CAAa,EAAE,CAAa;IAClD,OAAO,eAAe,qKAAC,OAAO,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,OAAO,iKAAC,OAAO,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,GAAG,CAAC,CAAA;AACjF,CAAC;AAYK,SAAU,MAAM,CAAC,GAAe;IACpC,OAAO;QACL,IAAI,EAAE,eAAe,qKAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC;QACtC,GAAG,EAAE,OAAO,iKAAC,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC;KAC7B,CAAA;AACH,CAAC;AAOK,SAAU,KAAK,CAAC,GAAsB;IAC1C,OAAO;QACL,IAAI,EAAE,eAAe,qKAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC;QACrC,GAAG,EAAE,OAAO,iKAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC;KAC5B,CAAA;AACH,CAAC","ignoreList":[0]}},
    {"offset": {"line": 494, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 511, "column": 0}, "map": {"version":3,"file":"types.js","sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/node_modules/%40ucans/core/dist/src/types.ts"],"sourcesContent":["import * as semver from \"./semver.js\"\nimport { SemVer } from \"./semver.js\"\nimport { SupportedEncodings } from \"uint8arrays/util/bases.js\" // @IMPORT\nimport { Capability, isCapability, isEncodedCapability } from \"./capability/index.js\"\nimport * as util from \"./util.js\"\nimport { DelegationChain, DelegationSemantics } from \"./attenuation.js\"\n\n\n// ðŸ’Ž\n\n\nexport type Ucan<Prf = string> = {\n  header: UcanHeader\n  payload: UcanPayload<Prf>\n  // We need to keep the encoded version around to preserve the signature\n  signedData: string\n  signature: string\n}\n\n\n\n// CHUNKS\n\n\nexport interface UcanParts<Prf = string> {\n  header: UcanHeader\n  payload: UcanPayload<Prf>\n}\n\nexport type UcanHeader = {\n  alg: string\n  typ: string\n  ucv: SemVer\n}\n\nexport type UcanPayload<Prf = string> = {\n  iss: string\n  aud: string\n  exp: number\n  nbf?: number\n  nnc?: string\n  att: Array<Capability>\n  fct?: Array<Fact>\n  prf: Array<Prf>\n}\n\n\n\n// FRAGMENTS\n\n\nexport type Fact = Record<string, unknown>\n\n\n\n// CRYPTOGRAPHY\n\nexport interface Didable {\n  did: () => string\n}\n\nexport interface ExportableKey {\n  export: (format?: Encodings) => Promise<string>\n}\n\nexport interface Keypair {\n  jwtAlg: string\n  sign: (msg: Uint8Array) => Promise<Uint8Array>\n}\n\nexport interface DidableKey extends Didable, Keypair {}\n\n// MISC\n\n\nexport type Encodings = SupportedEncodings\n\n\n// STORE\n\n\nexport interface IndexByAudience {\n  [ audienceDID: string ]: Array<{\n    processedUcan: Ucan\n    capabilities: DelegationChain[]\n  }>\n}\n\nexport interface StoreI {\n  add(ucan: Ucan): Promise<void> \n  getByAudience(audience: string): Ucan[] \n  findByAudience(audience: string, predicate: (ucan: Ucan) => boolean): Ucan | null \n  findWithCapability(\n    audience: string,\n    requiredCapability: Capability,\n    requiredIssuer: string,\n  ): Iterable<DelegationChain>   \n}\n\n// BUILDER\n\nexport interface BuildableState {\n  issuer: DidableKey\n  audience: string\n  expiration: number\n}\n\n\nexport interface DefaultableState {\n  capabilities: Capability[]\n  facts: Fact[]\n  proofs: Ucan[]\n  addNonce: boolean\n  notBefore?: number\n}\n\n// the state neccessary for being able to lookup fitting capabilities in the UCAN store\nexport interface CapabilityLookupCapableState {\n  issuer: Keypair\n  expiration: number\n}\n\nexport interface BuilderI<State extends Partial<BuildableState>> {\n  issuedBy(issuer: DidableKey): BuilderI<State & { issuer: DidableKey }>\n  toAudience(audience: string): BuilderI<State & { audience: string }>\n  withLifetimeInSeconds(seconds: number): BuilderI<State & { expiration: number }>\n  withExpiration(expiration: number): BuilderI<State & { expiration: number }>\n  withNotBefore(notBeforeTimestamp: number): BuilderI<State>\n  withFact(fact: Fact): BuilderI<State>\n  withFact(fact: Fact, ...facts: Fact[]): BuilderI<State>\n  withFact(fact: Fact, ...facts: Fact[]): BuilderI<State>\n  withNonce(): BuilderI<State>\n  claimCapability(capability: Capability): BuilderI<State>\n  claimCapability(capability: Capability, ...capabilities: Capability[]): BuilderI<State>\n  claimCapability(capability: Capability, ...capabilities: Capability[]): BuilderI<State>\n  delegateCapability(requiredCapability: Capability, store: StoreI): State extends CapabilityLookupCapableState ? BuilderI<State> : never\n  delegateCapability(requiredCapability: Capability, proof: DelegationChain, semantics: DelegationSemantics): State extends CapabilityLookupCapableState ? BuilderI<State> : never\n  delegateCapability(requiredCapability: Capability, storeOrProof: StoreI | DelegationChain, semantics?: DelegationSemantics): BuilderI<State>\n  buildPayload(): State extends BuildableState ? UcanPayload : never\n  buildPayload(): UcanPayload\n  build(): Promise<State extends BuildableState ? Ucan : never>\n  build(): Promise<Ucan>\n}\n\n\n// TYPE CHECKS\n\n\nexport function isKeypair(obj: unknown): obj is Keypair {\n  return util.isRecord(obj)\n    && util.hasProp(obj, \"jwtAlg\") && typeof obj.jwtAlg === \"string\"\n    && util.hasProp(obj, \"sign\") && typeof obj.sign === \"function\"\n}\n\nexport function isUcanHeader(obj: unknown): obj is UcanHeader {\n  return util.isRecord(obj)\n    && util.hasProp(obj, \"alg\") && typeof obj.alg === \"string\"\n    && util.hasProp(obj, \"typ\") && typeof obj.typ === \"string\"\n    && util.hasProp(obj, \"ucv\") && semver.isSemVer(obj.ucv)\n}\n\nexport function isUcanPayload(obj: unknown): obj is UcanPayload {\n  return util.isRecord(obj)\n    && util.hasProp(obj, \"iss\") && typeof obj.iss === \"string\"\n    && util.hasProp(obj, \"aud\") && typeof obj.aud === \"string\"\n    && util.hasProp(obj, \"exp\") && typeof obj.exp === \"number\"\n    && (!util.hasProp(obj, \"nbf\") || typeof obj.nbf === \"number\")\n    && (!util.hasProp(obj, \"nnc\") || typeof obj.nnc === \"string\")\n    && util.hasProp(obj, \"att\") && Array.isArray(obj.att) && obj.att.every(a => isCapability(a) || isEncodedCapability(a))\n    && (!util.hasProp(obj, \"fct\") || Array.isArray(obj.fct) && obj.fct.every(util.isRecord))\n    && util.hasProp(obj, \"prf\") && Array.isArray(obj.prf) && obj.prf.every(str => typeof str === \"string\")\n}"],"names":[],"mappings":";;;;;AAAA,OAAO,KAAK,MAAM,MAAM,aAAa,CAAA;AAGrC,OAAO,EAAc,YAAY,EAAE,mBAAmB,EAAE,MAAM,uBAAuB,CAAA;AACrF,OAAO,KAAK,IAAI,MAAM,WAAW,CAAA;;;;;AAgJ3B,SAAU,SAAS,CAAC,GAAY;IACpC,OAAO,IAAI,mJAAC,QAAQ,CAAC,GAAG,CAAC,IACpB,IAAI,mJAAC,OAAO,CAAC,GAAG,EAAE,QAAQ,CAAC,IAAI,OAAO,GAAG,CAAC,MAAM,KAAK,QAAQ,IAC7D,IAAI,mJAAC,OAAO,CAAC,GAAG,EAAE,MAAM,CAAC,IAAI,OAAO,GAAG,CAAC,IAAI,KAAK,UAAU,CAAA;AAClE,CAAC;AAEK,SAAU,YAAY,CAAC,GAAY;IACvC,OAAO,IAAI,mJAAC,QAAQ,CAAC,GAAG,CAAC,IACpB,IAAI,mJAAC,OAAO,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,OAAO,GAAG,CAAC,GAAG,KAAK,QAAQ,IACvD,IAAI,mJAAC,OAAO,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,OAAO,GAAG,CAAC,GAAG,KAAK,QAAQ,IACvD,IAAI,mJAAC,OAAO,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,MAAM,mJAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,CAAA;AAC3D,CAAC;AAEK,SAAU,aAAa,CAAC,GAAY;IACxC,OAAO,IAAI,mJAAC,QAAQ,CAAC,GAAG,CAAC,IACpB,IAAI,mJAAC,OAAO,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,OAAO,GAAG,CAAC,GAAG,KAAK,QAAQ,IACvD,IAAI,mJAAC,OAAO,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,OAAO,GAAG,CAAC,GAAG,KAAK,QAAQ,IACvD,IAAI,mJAAC,OAAO,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,OAAO,GAAG,CAAC,GAAG,KAAK,QAAQ,IACvD,CAAC,CAAC,IAAI,mJAAC,OAAO,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,OAAO,GAAG,CAAC,GAAG,KAAK,QAAQ,CAAC,IAC1D,CAAC,CAAC,IAAI,mJAAC,OAAO,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,OAAO,GAAG,CAAC,GAAG,KAAK,QAAQ,CAAC,IAC1D,IAAI,mJAAC,OAAO,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,GAAG,CAAC,GAAG,CAAC,KAAK,EAAC,CAAC,CAAC,EAAE,0LAAC,eAAA,AAAY,EAAC,CAAC,CAAC,8LAAI,sBAAA,AAAmB,EAAC,CAAC,CAAC,CAAC,IACnH,CAAC,CAAC,IAAI,mJAAC,OAAO,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,mJAAC,QAAQ,CAAC,CAAC,IACrF,IAAI,mJAAC,OAAO,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,GAAG,CAAC,GAAG,CAAC,KAAK,EAAC,GAAG,CAAC,EAAE,AAAC,OAAO,GAAG,KAAK,QAAQ,CAAC,CAAA;AAC1G,CAAC","ignoreList":[0]}},
    {"offset": {"line": 532, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 538, "column": 0}, "map": {"version":3,"file":"compatibility.js","sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/node_modules/%40ucans/core/dist/src/compatibility.ts"],"sourcesContent":["// A module to hold all the ugly compatibility logic\n// for getting from old UCANs to newer version UCANs.\n\nimport * as semver from \"./semver.js\"\n\nimport * as util from \"./util.js\"\nimport { SUPERUSER } from \"./capability/super-user.js\"\nimport { UcanParts, isUcanHeader, isUcanPayload } from \"./types.js\"\nimport { my } from \"./capability/index.js\"\n\n\nconst VERSION_0_3 = { major: 0, minor: 3, patch: 0 }\n\ntype UcanHeader_0_3_0 = {\n  alg: string\n  typ: string\n  uav: string\n}\n\ntype UcanPayload_0_3_0 = {\n  iss: string\n  aud: string\n  nbf?: number\n  exp: number\n  rsc: string | Record<string, string>\n  ptc: string\n  prf?: string\n}\n\nfunction isUcanHeader_0_3_0(obj: unknown): obj is UcanHeader_0_3_0 {\n  return util.isRecord(obj)\n    && util.hasProp(obj, \"alg\") && typeof obj.alg === \"string\"\n    && util.hasProp(obj, \"typ\") && typeof obj.typ === \"string\"\n    && util.hasProp(obj, \"uav\") && typeof obj.uav === \"string\"\n}\n\nfunction isUcanPayload_0_3_0(obj: unknown): obj is UcanPayload_0_3_0 {\n  return util.isRecord(obj)\n    && util.hasProp(obj, \"iss\") && typeof obj.iss === \"string\"\n    && util.hasProp(obj, \"aud\") && typeof obj.aud === \"string\"\n    && (!util.hasProp(obj, \"nbf\") || typeof obj.nbf === \"number\")\n    && util.hasProp(obj, \"exp\") && typeof obj.exp === \"number\"\n    && util.hasProp(obj, \"rsc\") && (typeof obj.rsc === \"string\" || util.isRecord(obj))\n    && util.hasProp(obj, \"ptc\") && typeof obj.ptc === \"string\"\n    && (!util.hasProp(obj, \"prf\") || typeof obj.prf === \"string\")\n}\n\n\nexport function handleCompatibility(header: unknown, payload: unknown): UcanParts {\n  const fail = (place: string, reason: string) => new Error(`Can't parse UCAN ${place}: ${reason}`)\n\n  if (!util.isRecord(header)) throw fail(\"header\", \"Invalid format: Expected a record\")\n\n  // parse either the \"ucv\" or \"uav\" as a version in the header\n  // we translate 'uav: 1.0.0' into 'ucv: 0.3.0'\n  let version: \"0.9.1\" | \"0.3.0\" = \"0.9.1\"\n  if (!util.hasProp(header, \"ucv\") || typeof header.ucv !== \"string\") {\n    if (!util.hasProp(header, \"uav\") || typeof header.uav !== \"string\") {\n      throw fail(\"header\", \"Invalid format: Missing version indicator\")\n    } else if (header.uav !== \"1.0.0\") {\n      throw fail(\"header\", `Unsupported version 'uav: ${header.uav}'`)\n    }\n    version = \"0.3.0\"\n  } else if (semver.lt(header.ucv, \"0.8.0\")) {\n    throw fail(\"header\", `Unsupported version 'ucv: ${header.ucv}'`)\n  }\n\n  if (semver.gte(version, \"0.8.0\")) {\n    if (typeof header.ucv !== \"string\") {\n      throw fail(\"header\", \"Invalid format: Missing 'ucv' key or 'ucv' is not a string\")\n    }\n    header.ucv = semver.parse(header.ucv)\n    if (header.ucv == null) {\n      throw fail(\"header\", \"Invalid format: 'ucv' string cannot be parsed into a semantic version\")\n    }\n    if (!isUcanHeader(header)) throw fail(\"header\", \"Invalid format\")\n    if (!isUcanPayload(payload)) throw fail(\"payload\", \"Invalid format\")\n    return { header, payload }\n  }\n\n  // we know it's version 0.3.0\n  if (!isUcanHeader_0_3_0(header)) throw fail(\"header\", \"Invalid version 0.3.0 format\")\n  if (!isUcanPayload_0_3_0(payload)) throw fail(\"payload\", \"Invalid version 0.3.0 format\")\n\n  return {\n    header: {\n      alg: header.alg,\n      typ: header.typ,\n      ucv: VERSION_0_3,\n    },\n    payload: {\n      iss: payload.iss,\n      aud: payload.aud,\n      nbf: payload.nbf,\n      exp: payload.exp,\n      att: (() => {\n        if (payload.rsc === SUPERUSER || typeof payload.rsc === \"string\") return [\n          my(SUPERUSER)\n        ]\n\n        const resources: Record<string, string> = payload.rsc\n        return Object.keys(resources).map(rscKey => {\n          return {\n            with: { scheme: rscKey, hierPart: resources[ rscKey ] },\n            can: payload.ptc === SUPERUSER\n              ? SUPERUSER\n              : { namespace: rscKey, segments: [ payload.ptc ] }\n          }\n        })\n      })(),\n      prf: payload.prf != null ? [ payload.prf ] : []\n    },\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 636, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 686, "column": 0}, "map": {"version":3,"file":"token.js","sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/node_modules/%40ucans/core/dist/src/token.ts"],"sourcesContent":["import * as uint8arrays from \"uint8arrays\" // @IMPORT\n\nimport * as semver from \"./semver.js\"\nimport * as capability from \"./capability/index.js\"\nimport * as util from \"./util.js\"\nimport Plugins from \"./plugins.js\"\n\nimport { Capability, isCapability, isEncodedCapability } from \"./capability/index.js\"\nimport { Fact, Keypair, DidableKey } from \"./types.js\"\nimport { Ucan, UcanHeader, UcanParts, UcanPayload } from \"./types.js\"\nimport { handleCompatibility } from \"./compatibility.js\"\n\n\n// CONSTANTS\n\n\nconst TYPE = \"JWT\"\nconst VERSION = { major: 0, minor: 8, patch: 1 }\n\n\n\n// COMPOSING\n\n\n/**\n * Create a UCAN, User Controlled Authorization Networks, JWT.\n *\n * ### Header\n *\n * `alg`, Algorithm, the type of signature.\n * `typ`, Type, the type of this data structure, JWT.\n * `ucv`, UCAN version.\n *\n * ### Payload\n *\n * `att`, Attenuation, a list of resources and capabilities that the ucan grants.\n * `aud`, Audience, the ID of who it's intended for.\n * `exp`, Expiry, unix timestamp of when the jwt is no longer valid.\n * `fct`, Facts, an array of extra facts or information to attach to the jwt.\n * `iss`, Issuer, the ID of who sent this.\n * `nbf`, Not Before, unix timestamp of when the jwt becomes valid.\n * `nnc`, Nonce, a randomly generated string, used to ensure the uniqueness of the jwt.\n * `prf`, Proofs, nested tokens with equal or greater privileges.\n *\n */\nexport const build = (plugins: Plugins) =>\n  ( params: {\n    // from/to\n    issuer: DidableKey\n    audience: string\n\n    // capabilities\n    capabilities?: Array<Capability>\n\n    // time bounds\n    lifetimeInSeconds?: number // expiration overrides lifetimeInSeconds\n    expiration?: number\n    notBefore?: number\n\n    // proofs / other info\n    facts?: Array<Fact>\n    proofs?: Array<string>\n    addNonce?: boolean\n  }): Promise<Ucan> => {\n  const keypair = params.issuer\n  const payload = buildPayload({ ...params, issuer: keypair.did() })\n  return signWithKeypair(plugins)(payload, keypair)\n}\n\n/**\n * Construct the payload for a UCAN.\n */\nexport function buildPayload(params: {\n  // from/to\n  issuer: string\n  audience: string\n\n  // capabilities\n  capabilities?: Array<Capability>\n\n  // time bounds\n  lifetimeInSeconds?: number // expiration overrides lifetimeInSeconds\n  expiration?: number\n  notBefore?: number\n\n  // proofs / other info\n  facts?: Array<Fact>\n  proofs?: Array<string>\n  addNonce?: boolean\n}): UcanPayload {\n  const {\n    issuer,\n    audience,\n    capabilities = [],\n    lifetimeInSeconds = 30,\n    expiration,\n    notBefore,\n    facts,\n    proofs = [],\n    addNonce = false\n  } = params\n\n  // Validate\n  if (!issuer.startsWith(\"did:\")) throw new Error(\"The issuer must be a DID\")\n  if (!audience.startsWith(\"did:\")) throw new Error(\"The audience must be a DID\")\n\n  // Timestamps\n  const currentTimeInSeconds = Math.floor(Date.now() / 1000)\n  const exp = expiration || (currentTimeInSeconds + lifetimeInSeconds)\n\n  // ðŸ“¦\n  return {\n    aud: audience,\n    att: capabilities,\n    exp,\n    fct: facts,\n    iss: issuer,\n    nbf: notBefore,\n    nnc: addNonce ? util.generateNonce() : undefined,\n    prf: proofs,\n  }\n}\n\n/**\n * Encloses a UCAN payload as to form a finalised UCAN.\n */\nexport const sign = (plugins: Plugins) =>\n  async (payload: UcanPayload,\n    jwtAlg: string,\n    signFn: (data: Uint8Array) => Promise<Uint8Array>,\n  ): Promise<Ucan> => {\n  const header: UcanHeader = {\n    alg: jwtAlg,\n    typ: TYPE,\n    ucv: VERSION,\n  }\n\n  // Issuer key type must match UCAN algorithm\n  if (!plugins.verifyIssuerAlg(payload.iss, jwtAlg)) {\n    throw new Error(\"The issuer's key type must match the given key type.\")\n  }\n\n  // Encode parts\n  const encodedHeader = encodeHeader(header)\n  const encodedPayload = encodePayload(payload)\n\n  // Sign\n  const signedData = `${encodedHeader}.${encodedPayload}`\n  const toSign = uint8arrays.fromString(signedData, \"utf8\")\n  const sig = await signFn(toSign)\n\n  // ðŸ“¦\n  // we freeze the object to make it more unlikely\n  // for signedData & header/payload to get out of sync\n  return Object.freeze({\n    header,\n    payload,\n    signedData,\n    signature: uint8arrays.toString(sig, \"base64url\")\n  })\n}\n\n/**\n * `sign` with a `Keypair`.\n */\nexport const signWithKeypair = (plugins: Plugins) =>\n  ( payload: UcanPayload,\n    keypair: Keypair,\n  ): Promise<Ucan> => {\n  return sign(plugins)(\n    payload,\n    keypair.jwtAlg,\n    data => keypair.sign(data),\n  )\n}\n\n\n\n// ENCODING\n\n\n/**\n * Encode a UCAN.\n *\n * @param ucan The UCAN to encode\n */\nexport function encode(ucan: Ucan<unknown>): string {\n  return `${ucan.signedData}.${ucan.signature}`\n}\n\n/**\n * Encode the header of a UCAN.\n *\n * @param header The UcanHeader to encode\n * @returns The header of a UCAN encoded as url-safe base64 JSON\n */\nexport function encodeHeader(header: UcanHeader): string {\n  const headerFormatted = {\n    ...header,\n    ucv: semver.format(header.ucv)\n  }\n  return uint8arrays.toString(\n    uint8arrays.fromString(JSON.stringify(headerFormatted), \"utf8\"),\n    \"base64url\"\n  )\n}\n\n/**\n * Encode the payload of a UCAN.\n *\n * NOTE: This will encode capabilities as well, so that it matches the UCAN spec.\n *       In other words, `{ with: { scheme, hierPart }, can: { namespace, segments } }`\n *       becomes `{ with: \"${scheme}:${hierPart}\", can: \"${namespace}/${segment}\" }`\n *\n * @param payload The UcanPayload to encode\n */\nexport function encodePayload(payload: UcanPayload): string {\n  const payloadWithEncodedCaps = {\n    ...payload,\n    att: payload.att.map(capability.encode)\n  }\n\n  return uint8arrays.toString(\n    uint8arrays.fromString(JSON.stringify(payloadWithEncodedCaps), \"utf8\"),\n    \"base64url\"\n  )\n}\n\n/**\n * Parse an encoded UCAN.\n *\n * @param encodedUcan The encoded UCAN.\n */\nexport function parse(encodedUcan: string): UcanParts {\n  const [ encodedHeader, encodedPayload, signature ] = encodedUcan.split(\".\")\n\n  if (encodedHeader == null || encodedPayload == null || signature == null) {\n    throw new Error(`Can't parse UCAN: ${encodedUcan}: Expected JWT format: 3 dot-separated base64url-encoded values.`)\n  }\n\n  // Header\n  let headerJson: string\n  let headerObject: unknown\n\n  try {\n    headerJson = uint8arrays.toString(\n      uint8arrays.fromString(encodedHeader, \"base64url\"),\n      \"utf8\"\n    )\n  } catch {\n    throw new Error(`Can't parse UCAN header: ${encodedHeader}: Can't parse as base64url.`)\n  }\n\n  try {\n    headerObject = JSON.parse(headerJson)\n  } catch {\n    throw new Error(`Can't parse UCAN header: ${encodedHeader}: Can't parse encoded JSON inside.`)\n  }\n\n  // Payload\n  let payloadJson: string\n  let payloadObject: unknown\n\n  try {\n    payloadJson = uint8arrays.toString(\n      uint8arrays.fromString(encodedPayload, \"base64url\"),\n      \"utf8\"\n    )\n  } catch {\n    throw new Error(`Can't parse UCAN payload: ${encodedPayload}: Can't parse as base64url.`)\n  }\n\n  try {\n    payloadObject = JSON.parse(payloadJson)\n  } catch {\n    throw new Error(`Can't parse UCAN payload: ${encodedPayload}: Can't parse encoded JSON inside.`)\n  }\n\n  // Compatibility layer\n  const { header, payload } = handleCompatibility(headerObject, payloadObject)\n\n  // Ensure proper types/structure\n  const parsedAttenuations = payload.att.reduce((acc: Capability[], cap: unknown): Capability[] => {\n    return isEncodedCapability(cap)\n      ? [ ...acc, capability.parse(cap) ]\n      : isCapability(cap) ? [ ...acc, cap ] : acc\n  }, [])\n\n  // Fin\n  return {\n    header: header,\n    payload: { ...payload, att: parsedAttenuations }\n  }\n}\n\n\n\n// VALIDATION\n\n/**\n * Validation options\n */\nexport interface ValidateOptions {\n  checkIssuer?: boolean\n  checkSignature?: boolean\n  checkIsExpired?: boolean\n  checkIsTooEarly?: boolean\n}\n\n/**\n * Parse & Validate **one layer** of a UCAN.\n * This doesn't validate attenutations and doesn't validate the whole UCAN chain.\n *\n * By default, this will check the signature and time bounds.\n *\n * @param encodedUcan the JWT-encoded UCAN to validate\n * @param options an optional parameter to configure turning off some validation options\n * @returns the parsed & validated UCAN (one layer)\n * @throws Error if the UCAN is invalid\n */\nexport const validate = (plugins: Plugins) => \n  async (encodedUcan: string, opts?: Partial<ValidateOptions>): Promise<Ucan> => {\n  const { checkIssuer = true, checkSignature = true, checkIsExpired = true, checkIsTooEarly = true } = opts ?? {}\n\n  const { header, payload } = parse(encodedUcan)\n  const [ encodedHeader, encodedPayload, signature ] = encodedUcan.split(\".\")\n\n  if (checkIssuer) {\n    const validIssuer = plugins.verifyIssuerAlg(payload.iss, header.alg)\n    if (!validIssuer) {\n      throw new Error(`Invalid UCAN: ${encodedUcan}: Issuer key type does not match UCAN's \\`alg\\` property.`)\n    }\n  }\n\n  if (checkSignature) {\n    const sigBytes = uint8arrays.fromString(signature, \"base64url\")\n    const data = uint8arrays.fromString(`${encodedHeader}.${encodedPayload}`, \"utf8\")\n    const validSig = await plugins.verifySignature(payload.iss, data, sigBytes)\n    if (!validSig) {\n      throw new Error(`Invalid UCAN: ${encodedUcan}: Signature invalid.`)\n    }\n  }\n\n  const signedData = `${encodedHeader}.${encodedPayload}`\n  const ucan: Ucan = { header, payload, signedData, signature }\n\n  if (checkIsExpired && isExpired(ucan)) {\n    throw new Error(`Invalid UCAN: ${encodedUcan}: Expired.`)\n  }\n\n  if (checkIsTooEarly && isTooEarly(ucan)) {\n    throw new Error(`Invalid UCAN: ${encodedUcan}: Not active yet (too early).`)\n  }\n\n  return ucan\n}\n\n/**\n * Proof validation options.\n */\nexport interface ValidateProofsOptions extends ValidateOptions {\n  /**\n   * Whether to check if the ucan's issuer matches its proofs audiences.\n   */\n  checkAddressing?: boolean\n  /**\n   * Whether to check if a ucan's time bounds are a subset of its proofs time bounds.\n   */\n  checkTimeBoundsSubset?: boolean\n  /**\n   * Whether to check if a ucan's version is bigger or equal to its proofs version.\n   */\n  checkVersionMonotonic?: boolean\n}\n\n/**\n * Iterates over all proofs and parses & validates them at the same time.\n * \n * If there's an audience/issuer mismatch, the iterated item will contain an `Error`.\n * Otherwise the iterated out will contain a `Ucan`.\n * \n * @param ucan a parsed UCAN\n * @param options optional ValidateOptions to use for validating each proof\n * @return an async iterator of the given ucan's proofs parsed & validated, or an `Error`\n *         for each proof that couldn't be validated or parsed.\n */\n\nexport const validateProofs = (plugins: Plugins) => \n  async function* ( ucan: Ucan,\n    opts?: Partial<ValidateProofsOptions>\n  ): AsyncIterable<Ucan | Error> {\n  const { checkAddressing = true, checkTimeBoundsSubset = true, checkVersionMonotonic = true } = opts || {}\n\n  for (const prf of ucan.payload.prf) {\n    try {\n      const proof = await validate(plugins)(prf, opts)\n\n      if (checkAddressing && ucan.payload.iss !== proof.payload.aud) {\n        throw new Error(`Invalid Proof: Issuer ${ucan.payload.iss} doesn't match parent's audience ${proof.payload.aud}`)\n      }\n\n      if (checkTimeBoundsSubset && proof.payload.nbf != null && ucan.payload.exp > proof.payload.nbf) {\n        throw new Error(`Invalid Proof: 'Not before' (${proof.payload.nbf}) is after parent's expiration (${ucan.payload.exp})`)\n      }\n\n      if (checkTimeBoundsSubset && ucan.payload.nbf != null && ucan.payload.nbf > proof.payload.exp) {\n        throw new Error(`Invalid Proof: Expiration (${proof.payload.exp}) is before parent's 'not before' (${ucan.payload.nbf})`)\n      }\n\n      if (checkVersionMonotonic && semver.lt(ucan.header.ucv, proof.header.ucv)) {\n        throw new Error(`Invalid Proof: Version (${proof.header.ucv}) is higher than parent's version (${ucan.header.ucv})`)\n      }\n\n      yield proof\n    } catch (e) {\n      if (e instanceof Error) {\n        yield e\n      } else {\n        yield new Error(`Error when trying to parse UCAN proof: ${e}`)\n      }\n    }\n  }\n}\n\n/**\n * Check if a UCAN is expired.\n *\n * @param ucan The UCAN to validate\n */\nexport function isExpired(ucan: Ucan): boolean {\n  return ucan.payload.exp <= Math.floor(Date.now() / 1000)\n}\n\n/**\n * Check if a UCAN is not active yet.\n *\n * @param ucan The UCAN to validate\n */\nexport const isTooEarly = (ucan: Ucan): boolean => {\n  if (ucan.payload.nbf == null) return false\n  return ucan.payload.nbf > Math.floor(Date.now() / 1000)\n}"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 982, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 988, "column": 0}, "map": {"version":3,"file":"attenuation.js","sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/node_modules/%40ucans/core/dist/src/attenuation.ts"],"sourcesContent":["import * as token from \"./token.js\"\nimport Plugins from \"./plugins.js\"\nimport { Capability } from \"./capability/index.js\"\nimport { Ucan } from \"./types.js\"\nimport { ResourcePointer } from \"./capability/resource-pointer.js\"\nimport { Ability } from \"./capability/ability.js\"\nimport { SUPERUSER, Superuser } from \"./capability/super-user.js\"\n\n\n// TYPES\n\n\n/**\n * UCAN capabilities can have arbitrary semantics for delegation.\n * These semantics can be configured via this record of functions.\n * \n * In most cases you may just want to use `equalCanDelegate` as your semantics,\n * but sometimes you want e.g. path behavior for a file-system-like resource:\n * `path:/parent/` should be able to delegate access to `path:/parent/child/`.\n */\nexport interface DelegationSemantics {\n  /**\n   * Whether a parent resource can delegate a child resource.\n   * \n   * An implementation may for example decide to return true for\n   * `canDelegateResource(resourcePointer.parse(\"path:/parent/\"), resourcePointer.parse(\"path:/parent/child/\"))`\n   */\n  canDelegateResource(parentResource: ResourcePointer, childResource: ResourcePointer): boolean\n  /**\n   * Whether a parent ability can delegate a child ability.\n   * \n   * An implementation may for example decide to return true for\n   * `canDelegateAbility(ability.parse(\"crud/UPDATE\"), ability.parse(\"crud/CREATE\"))`\n   */\n  canDelegateAbility(parentAbility: Ability, childAbility: Ability): boolean\n}\n\n\n/**\n * A delegation chain for a delegated capability or delegated ownership.\n * \n * This type represents a valid path of delegations through a UCAN.\n * \n * It can be cached as a sort of \"witness\" that a UCAN actually delegates a particular capability.\n *\n * Or it can be scanned to look for UCANs that may have become invalid due to revocation.\n */\nexport type DelegationChain\n  = DelegatedCapability\n  | DelegatedOwnership\n\n\n/**\n * A delegation chain that ends with a concrete capability.\n */\nexport interface DelegatedCapability {\n  /**\n   * The capability that the end of the chain grants.\n   */\n  capability: Capability\n  /**\n   * The specific UCAN in the chain witnessing the delegated capability.\n   */\n  ucan: Ucan\n  // will probably become an array in the future due to rights amplification\n  /**\n   * The rest of the delegation chain. This may include entries\n   * for `DelegatedOwnership`.\n   */\n  chainStep?: DelegationChain\n}\n\n/**\n * A delegation chain that ends with delegated ownership.\n * \n * This is ownership over a specific DID at a certain resource and ability scope.\n */\nexport interface DelegatedOwnership {\n  /**\n   * The DID that ownership is delegated for.\n   */\n  ownershipDID: string\n  /**\n   * The kinds of capabilites that can be delegated from the ownership.\n   */\n  scope: OwnershipScope\n  /**\n   * The specific UCAN in the chain witnessing the delegated ownership.\n   */\n  ucan: Ucan\n  /**\n   * The rest of the ownership delegation chain.\n   */\n  chainStep?: DelegatedOwnership\n}\n\n\n/**\n * This describes the scope of capabilities that are allowed to be delegated\n * from delegated ownership.\n */\nexport type OwnershipScope\n  = Superuser\n  | { scheme: string; ability: Ability }\n\n\n\n// FUNCTIONS\n\n\n/**\n * This computes all possible delegations from given UCAN with given\n * capability delegation semantics.\n * \n * For each entry in the attenuations array of the UCAN there will be at least\n * one delegation chain.\n * \n * These delegation chains are computed lazily, so that if parts of the UCAN have\n * been revoked or can't be loaded, this doesn't keep this function from figuring\n * out different ways of delegating a capability from the attenuations.\n * It also makes it possible to return early if a valid delegation chain has been found.\n */\nexport const delegationChains = (plugins: Plugins) =>\n  async function* ( \n    semantics: DelegationSemantics,\n    ucan: Ucan,\n    isRevoked: (ucan: Ucan) => Promise<boolean> = async () => false,\n  ): AsyncIterable<DelegationChain | Error> {\n\n  if (await isRevoked(ucan)) {\n    yield new Error(`UCAN Revoked: ${token.encode(ucan)}`)\n    return\n  }\n\n  yield* capabilitiesFromParenthood(ucan)\n  yield* capabilitiesFromDelegation(plugins, semantics, ucan, isRevoked)\n}\n\n\n/**\n * Figures out the implied root issuer from a delegation chain.\n * \n * For a given delegation chain this will give you the DID of who\n * \"started\" the chain, so who claims to be the \"owner\" of said capability.\n */\nexport function rootIssuer(delegationChain: DelegationChain): string {\n  if (\"capability\" in delegationChain) {\n    return delegationChain.chainStep == null\n      ? delegationChain.ucan.payload.iss\n      : rootIssuer(delegationChain.chainStep)\n  }\n  return delegationChain.ownershipDID\n}\n\n\n/**\n * The default delegation semantics.\n * This will just allow equal capabilities to be delegated,\n * except that it also accounts for superuser abilities.\n */\nexport const equalCanDelegate: DelegationSemantics = {\n  canDelegateResource(parentResource, childResource) {\n    if (parentResource.scheme !== childResource.scheme) {\n      return false\n    }\n\n    return parentResource.hierPart === childResource.hierPart\n  },\n\n  canDelegateAbility(parentAbility, childAbility) {\n    if (parentAbility === SUPERUSER) {\n      return true\n    }\n    if (childAbility === SUPERUSER) {\n      return false\n    }\n\n    if (parentAbility.namespace !== childAbility.namespace) {\n      return false\n    }\n\n    // Array equality\n    if (parentAbility.segments.length !== childAbility.segments.length) {\n      return false\n    }\n    return parentAbility.segments.reduce(\n      (acc, v, i) => acc && childAbility.segments[ i ] === v,\n      true as boolean\n    )\n  },\n}\n\n\nexport function capabilityCanBeDelegated(\n  semantics: DelegationSemantics,\n  capability: Capability,\n  fromDelegationChain: DelegationChain,\n): boolean {\n  if (\"capability\" in fromDelegationChain) {\n    return canDelegate(semantics, fromDelegationChain.capability, capability)\n  }\n  const ownershipScope = fromDelegationChain.scope\n  if (ownershipScope === SUPERUSER) {\n    return true\n  }\n  return ownershipScope.scheme == capability.with.scheme\n    && semantics.canDelegateAbility(ownershipScope.ability, capability.can)\n}\n\n\nexport function ownershipCanBeDelegated(\n  semantics: DelegationSemantics,\n  did: string,\n  scope: OwnershipScope,\n  fromDelegationChain: DelegatedOwnership\n): boolean {\n  if (did !== fromDelegationChain.ownershipDID) {\n    return false\n  }\n\n  const parentScope = fromDelegationChain.scope\n\n  // parent OwnershipScope can delegate child OwnershipScope\n\n  if (parentScope === SUPERUSER) {\n    return true\n  }\n  if (scope === SUPERUSER) {\n    return false\n  }\n  return parentScope.scheme === scope.scheme\n    && semantics.canDelegateAbility(parentScope.ability, scope.ability)\n}\n\n\n\n// ãŠ™ï¸ Internal\n\n\nfunction* capabilitiesFromParenthood(ucan: Ucan): Iterable<DelegationChain> {\n  for (const capability of ucan.payload.att) {\n    switch (capability.with.scheme.toLowerCase()) {\n      // If it's a \"my\" capability, it'll indicate an ownership delegation\n      case \"my\": {\n        const scope = capability.with.hierPart === SUPERUSER\n          ? SUPERUSER\n          : { scheme: capability.with.hierPart, ability: capability.can }\n\n        yield {\n          ownershipDID: ucan.payload.iss,\n          scope,\n          ucan,\n        }\n        break\n      }\n      // if it's another known capability, we can ignore them\n      // (they're not introduced by parenthood)\n      case \"as\":\n      case \"prf\":\n        break\n      // otherwise we assume it's a normal parenthood capability introduction\n      default:\n        yield { capability, ucan }\n    }\n  }\n}\n\n\nasync function* capabilitiesFromDelegation(\n  plugins: Plugins,\n  semantics: DelegationSemantics,\n  ucan: Ucan,\n  isRevoked: (ucan: Ucan) => Promise<boolean>,\n): AsyncIterable<DelegationChain | Error> {\n\n  let proofIndex = 0\n\n  for await (const proof of token.validateProofs(plugins)(ucan)) {\n    if (proof instanceof Error) {\n      yield proof\n      continue\n    }\n\n    for (const capability of ucan.payload.att) {\n      try {\n        switch (capability.with.scheme.toLowerCase()) {\n          case \"my\": continue // cannot be delegated, only introduced by parenthood.\n          case \"as\": {\n            yield* handleAsDelegation(plugins, semantics, capability, ucan, proof, isRevoked)\n            break\n          }\n          case \"prf\": {\n            yield* handlePrfDelegation(plugins, semantics, capability, ucan, proof, proofIndex, isRevoked)\n            break\n          }\n          default: {\n            yield* handleNormalDelegation(plugins, semantics, capability, ucan, proof, isRevoked)\n          }\n        }\n      } catch (e) {\n        yield error(e)\n      }\n    }\n\n    proofIndex++\n  }\n\n  function error(e: unknown): Error {\n    if (e instanceof Error) {\n      return e\n    } else {\n      return new Error(`Error during capability delegation checking: ${e}`)\n    }\n  }\n}\n\n\nasync function* handleAsDelegation(\n  plugins: Plugins,\n  semantics: DelegationSemantics,\n  capability: Capability,\n  ucan: Ucan,\n  proof: Ucan,\n  isRevoked: (ucan: Ucan) => Promise<boolean>,\n): AsyncIterable<DelegatedOwnership | Error> {\n  const split = capability.with.hierPart.split(\":\")\n  const scheme = split[ split.length - 1 ]\n  const ownershipDID = split.slice(0, -1).join(\":\")\n  const scope = scheme === SUPERUSER\n    ? SUPERUSER\n    : { scheme, ability: capability.can }\n\n  for await (const delegationChain of delegationChains(plugins)(semantics, proof, isRevoked)) {\n    if (delegationChain instanceof Error) {\n      yield delegationChain\n      continue\n    }\n    if (!(\"ownershipDID\" in delegationChain)) {\n      continue\n    }\n    if (ownershipCanBeDelegated(\n      semantics,\n      ownershipDID,\n      scope,\n      delegationChain\n    )) {\n      yield {\n        ownershipDID,\n        scope,\n        ucan,\n        chainStep: delegationChain\n      }\n    }\n  }\n}\n\n\nasync function* handlePrfDelegation(\n  plugins: Plugins,\n  semantics: DelegationSemantics,\n  capability: Capability,\n  ucan: Ucan,\n  proof: Ucan,\n  proofIndex: number,\n  isRevoked: (ucan: Ucan) => Promise<boolean>,\n): AsyncIterable<DelegatedCapability | Error> {\n  if (\n    capability.with.hierPart !== SUPERUSER\n    && parseInt(capability.with.hierPart, 10) !== proofIndex\n  ) {\n    // if it's something like prf:2, we need to make sure that\n    // we only process the delegation if proofIndex === 2\n    return\n  }\n  for await (const delegationChain of delegationChains(plugins)(semantics, proof, isRevoked)) {\n    if (delegationChain instanceof Error) {\n      yield delegationChain\n      continue\n    }\n    if (!(\"capability\" in delegationChain)) {\n      continue\n    }\n    yield {\n      capability: delegationChain.capability,\n      ucan,\n      chainStep: delegationChain\n    }\n  }\n}\n\n\nasync function* handleNormalDelegation(\n  plugins: Plugins,\n  semantics: DelegationSemantics,\n  capability: Capability,\n  ucan: Ucan,\n  proof: Ucan,\n  isRevoked: (ucan: Ucan) => Promise<boolean>,\n): AsyncIterable<DelegatedCapability | Error> {\n  for await (const delegationChain of delegationChains(plugins)(semantics, proof, isRevoked)) {\n    if (delegationChain instanceof Error) {\n      yield delegationChain\n      continue\n    }\n    if (!capabilityCanBeDelegated(semantics, capability, delegationChain)) {\n      continue\n    }\n    yield {\n      capability,\n      ucan,\n      chainStep: delegationChain\n    }\n  }\n}\n\n\nfunction canDelegate(\n  semantics: DelegationSemantics,\n  parentCapability: Capability,\n  childCapability: Capability,\n): boolean {\n  return semantics.canDelegateResource(parentCapability.with, childCapability.with)\n    && semantics.canDelegateAbility(parentCapability.can, childCapability.can)\n}\n\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1377, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1383, "column": 0}, "map": {"version":3,"file":"verify.js","sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/node_modules/%40ucans/core/dist/src/verify.ts"],"sourcesContent":["import * as token from \"./token.js\"\nimport Plugins from \"./plugins.js\"\nimport { capabilityCanBeDelegated, DelegationSemantics, DelegationChain, delegationChains, equalCanDelegate, rootIssuer } from \"./attenuation.js\"\nimport { Capability, isCapability } from \"./capability/index.js\"\nimport { Fact, Ucan } from \"./types.js\"\n\n\nexport type Result<Ok, Err = Error>\n  = { ok: true; value: Ok }\n  | { ok: false; error: Err }\n\nconst ok: <T, E>(k: T) => Result<T, E> = k => ({ ok: true, value: k })\nconst err: <T, E>(e: E) => Result<T, E> = e => ({ ok: false, error: e })\n\n\nexport interface VerifyOptions {\n  /**\n   * the DID of the callee of this function. The expected audience of the outermost level of the UCAN.\n   * NOTE: This DID should not be hardcoded in production calls to this function.\n   */\n  audience: string\n  /**\n   * a non-empty list of capabilities required for this UCAN invocation. The root issuer and capability\n   * should be derived from something like your HTTP request parameters. They identify the resource\n   * that's access-controlled.\n   */\n  requiredCapabilities: { capability: Capability; rootIssuer: string }[]\n   /**\n   * an optional record of functions that specify what the rules for delegating capabilities are.\n   * If not provided, the default semantics will be `equalCanDelegate`.\n   */\n  semantics?: DelegationSemantics\n  /**\n   * an async predicate on UCANs to figure out whether they've been revoked or not.\n   * Usually that means checking whether the hash of the UCAN is in a list of revoked UCANs.\n   * If not provided, it will assume no UCAN to be revoked.\n   */\n   isRevoked?: (ucan: Ucan) => Promise<boolean>\n  /**\n   * an optional function that's given the list of facts in the root UCAN and returns a boolean indicating\n   * whether the facts include everything you expect for the UCAN invocation to check.\n   * By default this will ignore all facts in the UCAN and just return true.\n   */\n  checkFacts?: (facts: Fact[]) => boolean\n}\n\n\n/**\n * Verify a UCAN for an invocation.\n *\n * @param ucan a UCAN to verify for invocation in JWT format. (starts with 'eyJ...' and has two '.' in it)\n *\n * @param options required and optional verification options see {@link VerifyOptions}\n *\n * @throws TypeError if the passed arguments don't match what is expected\n */\nexport const verify = (plugins: Plugins) => \n  async (ucan: string, options: VerifyOptions): Promise<Result<Verification[], Error[]>> => {\n  const { audience, requiredCapabilities } = options\n  const semantics = options.semantics ?? equalCanDelegate\n  const isRevoked = options.isRevoked ?? (async () => false)\n  const checkFacts = options.checkFacts ?? (() => true)\n  // type-check arguments\n  if (typeof ucan !== \"string\") {\n    throw new TypeError(`Expected an encoded UCAN string as first argument, but got ${ucan}`)\n  }\n  if (typeof audience !== \"string\" || !audience.startsWith(\"did:\")) {\n    throw new TypeError(`Expected a DID string as second argument, but got ${audience}`)\n  }\n  if (typeof isRevoked !== \"function\") {\n    throw new TypeError(`Expected a function returning a promise as third argument, but got ${isRevoked}`)\n  }\n  if (!Array.isArray(requiredCapabilities)) {\n    throw new TypeError(`Expected an array as fourth argument, but got ${requiredCapabilities}`)\n  }\n  if (requiredCapabilities.length < 1) {\n    throw new TypeError(`Expected a non-empty list of required capabilities as 4th argument.`)\n  }\n  if (requiredCapabilities.some(req => !isCapability(req.capability) || typeof req.rootIssuer !== \"string\" || !req.rootIssuer.startsWith(\"did:\"))) {\n    throw new TypeError(`Expected an array of records of capabilities and rootIssuers as DID strings as 4th argument, but got ${requiredCapabilities}`)\n  }\n  if (typeof semantics.canDelegateResource !== \"function\" || typeof semantics.canDelegateAbility !== \"function\") {\n    throw new TypeError(`Expected a record with two functions 'canDelegateResource' and 'canDelegateAbility' as 5th argument, but got ${semantics}`)\n  }\n  if (typeof checkFacts !== \"function\") {\n    throw new TypeError(`Expected a function as 6th argument, but got ${checkFacts}`)\n  }\n\n  try {\n    // Verify the UCAN\n    const decoded = await token.validate(plugins)(ucan)\n\n    // Check that it's addressed to us\n    if (decoded.payload.aud !== audience) {\n      return err([ new Error(`Invalid UCAN: Expected audience to be ${audience}, but it's ${decoded.payload.aud}`) ])\n    }\n\n    const errors: Error[] = []\n    const remaining = new Set(requiredCapabilities)\n    const proven: Verification[] = []\n\n    // Check that all required capabilities are verified\n    loop: for await (const delegationChain of delegationChains(plugins)(semantics, decoded, isRevoked)) {\n      if (delegationChain instanceof Error) {\n        errors.push(delegationChain)\n        continue\n      }\n\n      // Try to look for capabilities from given delegation chain\n      for (const expected of remaining) {\n        if (\n          capabilityCanBeDelegated(semantics, expected.capability, delegationChain)\n          && rootIssuer(delegationChain) === expected.rootIssuer\n        ) {\n          remaining.delete(expected)\n          proven.push({\n            ...expected,\n            proof: delegationChain\n          })\n        }\n      }\n\n      // If we've already verified all, we don't need to keep looking\n      if (remaining.size === 0) {\n        break loop\n      }\n    }\n\n    return remaining.size > 0 ? err(errors) : ok(proven)\n\n  } catch (e) {\n    return err([ e instanceof Error ? e : new Error(`Unknown error during UCAN verification: ${e}`) ])\n  }\n}\n\nexport interface Verification {\n  capability: Capability\n  rootIssuer: string\n  proof: DelegationChain\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1537, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1543, "column": 0}, "map": {"version":3,"file":"builder.js","sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/node_modules/%40ucans/core/dist/src/builder.ts"],"sourcesContent":["import * as token from \"./token.js\"\nimport * as util from \"./util.js\"\nimport Plugins from \"./plugins.js\"\n\nimport { Fact, UcanPayload, isKeypair, Ucan, DidableKey, StoreI, BuilderI, BuildableState, CapabilityLookupCapableState, DefaultableState } from \"./types.js\"\nimport { Capability, isCapability } from \"./capability/index.js\"\nimport { capabilityCanBeDelegated, DelegationSemantics, DelegationChain } from \"./attenuation.js\"\n\n\n\nfunction isBuildableState(obj: unknown): obj is BuildableState {\n  return util.isRecord(obj)\n    && util.hasProp(obj, \"issuer\") && isKeypair(obj.issuer)\n    && util.hasProp(obj, \"audience\") && typeof obj.audience === \"string\"\n    && util.hasProp(obj, \"expiration\") && typeof obj.expiration === \"number\"\n}\n\nfunction isCapabilityLookupCapableState(obj: unknown): obj is CapabilityLookupCapableState {\n  return util.isRecord(obj)\n    && util.hasProp(obj, \"issuer\") && isKeypair(obj.issuer)\n    && util.hasProp(obj, \"expiration\") && typeof obj.expiration === \"number\"\n}\n\n// type BuilderConstructor = new <State extends Partial<BuildableState>>(state: State, defaultable: DefaultableState) => BuilderI<State>\ntype BuilderConstructor = { \n  new <State extends Partial<BuildableState>>(state: State, defaultable: DefaultableState): BuilderI<State> \n  create(): BuilderI<Record<string, never>> \n}\n\n/**\n * A builder API for UCANs.\n *\n * Supports grabbing UCANs from a UCAN `Store` for proofs (see `delegateCapability`).\n *\n * Example usage:\n *\n * ```ts\n * const ucan = await Builder.create()\n *   .issuedBy(aliceKeypair)\n *   .toAudience(bobDID)\n *   .withLifetimeInSeconds(30)\n *   .claimCapability({ email: \"my@email.com\", cap: \"SEND\" })\n *   .delegateCapability(emailSemantics, { email: \"my-friends@email.com\", cap: \"SEND\" }, proof)\n *   .build()\n * ```\n */\nconst mkBuilderClass = (plugins: Plugins): BuilderConstructor => {\n\n  return class Builder<State extends Partial<BuildableState>> implements BuilderI<State> {\n\n    private state: State // portion of the state that's required to be set before building\n    private defaultable: DefaultableState // portion of the state that has sensible defaults\n\n    constructor(state: State, defaultable: DefaultableState) {\n      this.state = state\n      this.defaultable = defaultable\n    }\n\n    /**\n     * Create an empty builder.\n     * Before finalising the builder, you need to at least call\n     * - `issuedBy`\n     * - `toAudience` and\n     * - `withLifetimeInSeconds` or `withExpiration`.\n     * To finalise the builder, call its `build` or `buildPayload` method.\n     */\n    static create(): Builder<Record<string, never>> {\n        return new Builder({}, { capabilities: [], facts: [], proofs: [], addNonce: false })\n    }\n\n    /**\n     * @param issuer The issuer as a DID string (\"did:key:...\").\n     *\n     * The UCAN must be signed with the private key of the issuer to be valid.\n     */\n    issuedBy(issuer: DidableKey): Builder<State & { issuer: DidableKey }> {\n      if (!isKeypair(issuer)) {\n        throw new TypeError(`Expected a Keypair, but got ${issuer}`)\n      }\n      return new Builder({ ...this.state, issuer }, this.defaultable)\n    }\n\n    /**\n     * @param audience The audience as a DID string (\"did:key:...\").\n     *\n     * This is the identity this UCAN transfers rights to.\n     * It could e.g. be the DID of a service you're posting this UCAN as a JWT to,\n     * or it could be the DID of something that'll use this UCAN as a proof to\n     * continue the UCAN chain as an issuer.\n     */\n    toAudience(audience: string): Builder<State & { audience: string }> {\n      if (typeof audience !== \"string\") {\n        throw new TypeError(`Expected audience DID as string, but got ${audience}`)\n      }\n      return new Builder({ ...this.state, audience }, this.defaultable)\n    }\n\n    /**\n     * @param seconds The number of seconds from the calltime of this function\n     *   to set the expiry timestamp to.\n     */\n    withLifetimeInSeconds(seconds: number): Builder<State & { expiration: number }> {\n      if (typeof seconds !== \"number\") {\n        throw new TypeError(`Expected seconds as number, but got ${seconds}`)\n      }\n      if (!isFinite(seconds) || seconds <= 0) {\n        throw new TypeError(`Expected seconds to be a positive number, but got ${seconds}`)\n      }\n      return this.withExpiration(Math.floor(Date.now() / 1000) + seconds)\n    }\n\n    /**\n     * @param expiration The UTCTime timestamp (in seconds) for when the UCAN should expire.\n     */\n    withExpiration(expiration: number): Builder<State & { expiration: number }> {\n      if (typeof expiration !== \"number\" || !isFinite(expiration)) {\n        throw new TypeError(`Expected expiration as number, but got ${expiration}`)\n      }\n      if (this.defaultable.notBefore != null && expiration < this.defaultable.notBefore) {\n        throw new Error(`Can't set expiration to ${expiration} which is before 'notBefore': ${this.defaultable.notBefore}`)\n      }\n      return new Builder({ ...this.state, expiration }, this.defaultable)\n    }\n\n    /**\n     * @param notBeforeTimestamp The UTCTime timestamp (in seconds) of when the UCAN becomes active.\n     */\n    withNotBefore(notBeforeTimestamp: number): Builder<State> {\n      if (typeof notBeforeTimestamp !== \"number\" || !isFinite(notBeforeTimestamp)) {\n        throw new TypeError(`Expected notBeforeTimestamp as number, but got ${notBeforeTimestamp}`)\n      }\n      if (util.hasProp(this.state, \"expiration\") && typeof this.state.expiration === \"number\" && this.state.expiration < notBeforeTimestamp) {\n        throw new Error(`Can't set 'notBefore' to ${notBeforeTimestamp} which is after expiration: ${this.state.expiration}`)\n      }\n      return new Builder(this.state, { ...this.defaultable, notBefore: notBeforeTimestamp })\n    }\n\n    /**\n     * @param fact Any fact or proof of knowledge in this UCAN as a record.\n     * @param facts Arbitrary more facts or proofs of knowledge.\n     */\n    withFact(fact: Fact): Builder<State>\n    withFact(fact: Fact, ...facts: Fact[]): Builder<State>\n    withFact(fact: Fact, ...facts: Fact[]): Builder<State> {\n      if (!util.isRecord(fact) || facts.some(fct => !util.isRecord(fct))) {\n        throw new TypeError(`Expected fact(s) to be a record, but got ${fact}`)\n      }\n      return new Builder(this.state, {\n        ...this.defaultable,\n        facts: [ ...this.defaultable.facts, fact, ...facts ]\n      })\n    }\n\n    /**\n     * Will ensure that the built UCAN includes a number used once.\n     */\n    withNonce(): Builder<State> {\n      return new Builder(this.state, { ...this.defaultable, addNonce: true })\n    }\n\n    /**\n     * Claim capabilities 'by parenthood'.\n     */\n    claimCapability(capability: Capability): Builder<State>\n    claimCapability(capability: Capability, ...capabilities: Capability[]): Builder<State>\n    claimCapability(capability: Capability, ...capabilities: Capability[]): Builder<State> {\n      if (!isCapability(capability)) {\n        throw new TypeError(`Expected capability, but got ${JSON.stringify(capability, null, \" \")}`)\n      }\n      return new Builder(this.state, {\n        ...this.defaultable,\n        capabilities: [ ...this.defaultable.capabilities, capability, ...capabilities ]\n      })\n    }\n\n    /**\n     * Delegate capabilities from a given proof to the audience of the UCAN you're building.\n     *\n     * @param semantics The rules for which delegations of capabilities are allowed.\n     * @param requiredCapability The capability you want to delegate.\n     *\n     * Then, one of\n     * @param proof The proof chain that grants the issuer of this UCAN at least the capabilities you want to delegate, or\n     * @param store The UCAN store in which to try to find a UCAN granting you enough capabilities to delegate given capabilities.\n     *\n     * @throws If given store can't provide a UCAN for delegating given capability\n     * @throws If given proof can't be used to delegate given capability\n     * @throws If the builder hasn't set an issuer and expiration yet\n     */\n    delegateCapability(requiredCapability: Capability, store: StoreI): State extends CapabilityLookupCapableState ? Builder<State> : never\n    delegateCapability(requiredCapability: Capability, proof: DelegationChain, semantics: DelegationSemantics): State extends CapabilityLookupCapableState ? Builder<State> : never\n    delegateCapability(requiredCapability: Capability, storeOrProof: StoreI | DelegationChain, semantics?: DelegationSemantics): Builder<State> {\n      if (!isCapability(requiredCapability)) {\n        throw new TypeError(`Expected 'requiredCapability' as a second argument, but got ${requiredCapability}`)\n      }\n      if (!isCapabilityLookupCapableState(this.state)) {\n        throw new Error(`Can't delegate capabilities without having these paramenters set in the builder: issuer and expiration.`)\n      }\n\n      function isProof(proof: StoreI | DelegationChain): proof is DelegationChain {\n        return util.hasProp(proof, \"capability\") || util.hasProp(proof, \"ownershipDID\")\n      }\n\n      if (isProof(storeOrProof)) {\n        if (semantics == null) {\n          throw new TypeError(`Expected 'semantics' as third argument if a 'proof' DelegationChain was passed as second.`)\n        }\n        const proof: DelegationChain = storeOrProof\n        const ucan = proof.ucan\n        if (!capabilityCanBeDelegated(semantics, requiredCapability, proof)) {\n          throw new Error(`Can't add capability to UCAN: Given proof doesn't give required rights to delegate.`)\n        }\n        return new Builder(this.state, {\n          ...this.defaultable,\n          capabilities: [ ...this.defaultable.capabilities, requiredCapability ],\n          proofs: this.defaultable.proofs.find(p => token.encode(p) === token.encode(ucan)) == null\n            ? [ ...this.defaultable.proofs, ucan ]\n            : this.defaultable.proofs\n        })\n      } else {\n        const store: StoreI = storeOrProof\n        const issuer = this.state.issuer.did()\n        // we look up a proof that has our issuer as an audience\n        const result = util.first(store.findWithCapability(issuer, requiredCapability, issuer))\n        if (result != null) {\n          const ucan = result.ucan\n          const ucanEncoded = token.encode(ucan)\n          return new Builder(this.state, {\n            ...this.defaultable,\n            capabilities: [ ...this.defaultable.capabilities, requiredCapability ],\n            proofs: this.defaultable.proofs.find(proof => token.encode(proof) === ucanEncoded) == null\n              ? [ ...this.defaultable.proofs, ucan ]\n              : this.defaultable.proofs\n          })\n        } else {\n          throw new Error(`Couldn't add capability to UCAN. Couldn't find anything providing this capability in given store.`)\n        }\n      }\n    }\n\n    /**\n     * Build the UCAN body. This can be used if you want to sign the UCAN yourself afterwards.\n     */\n    buildPayload(): State extends BuildableState ? UcanPayload : never\n    buildPayload(): UcanPayload {\n      if (!isBuildableState(this.state)) {\n        throw new Error(`Builder is missing one of the required properties before it can be built: issuer, audience and expiration.`)\n      }\n      return token.buildPayload({\n        issuer: this.state.issuer.did(),\n        audience: this.state.audience,\n\n        expiration: this.state.expiration,\n        notBefore: this.defaultable.notBefore,\n        addNonce: this.defaultable.addNonce,\n\n        capabilities: this.defaultable.capabilities,\n        facts: this.defaultable.facts,\n        proofs: this.defaultable.proofs.map(proof => token.encode(proof)),\n      })\n    }\n\n    /**\n     * Finalize: Build and sign the UCAN.\n     *\n     * @throws If the builder hasn't yet been set an issuer, audience and expiration.\n     */\n    async build(): Promise<State extends BuildableState ? Ucan : never>\n    async build(): Promise<Ucan> {\n      if (!isBuildableState(this.state)) {\n        throw new Error(`Builder is missing one of the required properties before it can be built: issuer, audience and expiration.`)\n      }\n      const payload = this.buildPayload()\n      return await token.signWithKeypair(plugins)(payload, this.state.issuer)\n    }\n\n  }\n\n}\n\nexport default mkBuilderClass"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1803, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1809, "column": 0}, "map": {"version":3,"file":"store.js","sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/node_modules/%40ucans/core/dist/src/store.ts"],"sourcesContent":["import * as token from \"./token.js\"\nimport Plugins from \"./plugins.js\"\nimport { capabilityCanBeDelegated, DelegationSemantics, DelegationChain, delegationChains, rootIssuer } from \"./attenuation.js\"\nimport { IndexByAudience, StoreI, Ucan } from \"./types.js\"\nimport { Capability } from \"./capability/index.js\"\n\ntype StoreConstructor = {\n  new (knownSemantics: DelegationSemantics, index: IndexByAudience): StoreI\n  empty(knownSemantics: DelegationSemantics): StoreI\n  fromTokens(knownSemantics: DelegationSemantics, tokens: Iterable<string> | AsyncIterable<string>): Promise<StoreI>\n}\n\nconst mkStoreClass = (plugins: Plugins): StoreConstructor => {\n  return class Store implements StoreI{\n\n    private index: IndexByAudience\n    private knownSemantics: DelegationSemantics\n\n    constructor(knownSemantics: DelegationSemantics, index: IndexByAudience) {\n      this.index = index\n      this.knownSemantics = knownSemantics\n    }\n\n    static empty(knownSemantics: DelegationSemantics): Store {\n      return new Store(knownSemantics, {})\n    }\n\n    static async fromTokens( \n      knownSemantics: DelegationSemantics,\n      tokens: Iterable<string> | AsyncIterable<string>,\n    ): Promise<Store> {\n      const store = Store.empty(knownSemantics)\n      for await (const encodedUcan of tokens) {\n        const ucan = await token.validate(plugins)(encodedUcan)\n        await store.add(ucan)\n      }\n      return store\n    }\n\n    async add(ucan: Ucan): Promise<void> {\n      const audience = ucan.payload.aud\n      const byAudience = this.index[ audience ] ?? []\n      const encoded = token.encode(ucan)\n      \n      if (byAudience.find(stored => token.encode(stored.processedUcan) === encoded) != null) {\n        return\n      }\n\n      const chains = []\n      for await (const delegationChain of delegationChains(plugins)(this.knownSemantics, ucan)) {\n        if (delegationChain instanceof Error) {\n          console.warn(`Delegation chain error while storing UCAN:`, delegationChain)\n          continue\n        }\n        chains.push(delegationChain)\n      }\n\n      // Also do this *after* the all awaits to prevent races.\n      if (byAudience.find(stored => token.encode(stored.processedUcan) === encoded) != null) {\n        return\n      }\n\n      byAudience.push({\n        processedUcan: ucan,\n        capabilities: chains\n      })\n      this.index[ audience ] = byAudience\n    }\n\n    getByAudience(audience: string): Ucan[] {\n      return (this.index[ audience ] ?? []).map(elem => elem.processedUcan)\n    }\n\n    findByAudience(audience: string, predicate: (ucan: Ucan) => boolean): Ucan | null {\n      return this.index[ audience ]?.find(elem => predicate(elem.processedUcan))?.processedUcan ?? null\n    }\n\n    *findWithCapability(\n      audience: string,\n      requiredCapability: Capability,\n      requiredIssuer: string,\n    ): Iterable<DelegationChain> {\n      const cache = this.index[ audience ]\n\n      if (cache == null) {\n        return\n      }\n\n      for (const cacheElement of cache) {\n        for (const delegationChain of cacheElement.capabilities) {\n          if (capabilityCanBeDelegated(this.knownSemantics, requiredCapability, delegationChain)\n            && rootIssuer(delegationChain) === requiredIssuer) {\n              yield delegationChain\n          }\n        }\n      }\n    }\n\n  }\n}\n\nexport default mkStoreClass"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1967, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1973, "column": 0}, "map": {"version":3,"file":"plugins.js","sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/node_modules/%40ucans/core/dist/src/plugins.ts"],"sourcesContent":["import * as uint8arrays from \"uint8arrays\"\n\nexport type DidKeyPlugin = {\n  prefix: Uint8Array\n  jwtAlg: string\n  verifySignature: (did: string, data: Uint8Array, sig: Uint8Array) => Promise<boolean>\n}\n\nexport type DidMethodPlugin = {\n  checkJwtAlg: (did: string, jwtAlg: string) => boolean\n  verifySignature: (did: string, data: Uint8Array, sig: Uint8Array) => Promise<boolean>\n}\n\nexport class Plugins {\n\n  constructor(\n    public keys: DidKeyPlugin[],\n    public methods: Record<string, DidMethodPlugin>\n  ) {}\n\n  verifyIssuerAlg(did: string, jwtAlg: string): boolean {\n    const didMethod = parseDidMethod(did)\n    if(didMethod === \"key\") {\n      const bytes = parsePrefixedBytes(did)\n      for (const keyPlugin of this.keys) {\n        if(hasPrefix(bytes, keyPlugin.prefix)) {\n          return jwtAlg === keyPlugin.jwtAlg\n        }\n      }\n    } else {\n      const maybePlugin = this.methods[didMethod]\n      if(maybePlugin) {\n        return maybePlugin.checkJwtAlg(did, jwtAlg)\n      }\n    }\n    throw new Error(`DID method not supported by plugins: ${did}`)\n  }\n\n  async verifySignature(did: string, data: Uint8Array, sig: Uint8Array): Promise<boolean> {\n    const didMethod = parseDidMethod(did)\n    if(didMethod === \"key\") {\n      const bytes = parsePrefixedBytes(did)\n      for (const keyPlugin of this.keys) {\n        if(hasPrefix(bytes, keyPlugin.prefix)) {\n          return keyPlugin.verifySignature(did, data, sig)\n        }\n      }\n    } else {\n      const maybePlugin = this.methods[didMethod]\n      if (maybePlugin) {\n        return maybePlugin.verifySignature(did, data, sig)\n      }\n    }\n    throw new Error(`DID method not supported by plugins: ${did}`)\n  }\n}\n\nexport default Plugins\n\nconst hasPrefix = (\n  prefixedKey: Uint8Array,\n  prefix: Uint8Array\n): boolean => {\n  return uint8arrays.equals(prefix, prefixedKey.subarray(0, prefix.byteLength))\n}\n\nconst BASE58_DID_PREFIX = \"did:key:z\"\n\n// @TODO would be better to follow the actual varint spec here (instead of guess & check):\n// https://github.com/multiformats/unsigned-varint \nconst parsePrefixedBytes = (did: string): Uint8Array => {\n  if(!did.startsWith(BASE58_DID_PREFIX)) {\n    throw new Error(`Not a valid base58 formatted did:key: ${did}`)\n  } \n  return uint8arrays.fromString(\n    did.slice(BASE58_DID_PREFIX.length),\n    \"base58btc\"\n  )\n}\n\nconst parseDidMethod = (did: string) => {\n  const parts = did.split(\":\")\n  if(parts[0] !== \"did\") {\n    throw new Error(`Not a DID: ${did}`)\n  }\n  if(parts[1].length < 1) {\n    throw new Error(`No DID method included: ${did}`)\n  }\n  return parts[1]\n}"],"names":[],"mappings":";;;;AAAA,OAAO,KAAK,WAAW,MAAM,aAAa,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAapC,MAAO,OAAO;IAElB,YACS,IAAoB,EACpB,OAAwC,CAAA;QADxC,IAAA,CAAA,IAAI,GAAJ,IAAI,CAAgB;QACpB,IAAA,CAAA,OAAO,GAAP,OAAO,CAAiC;IAC9C,CAAC;IAEJ,eAAe,CAAC,GAAW,EAAE,MAAc,EAAA;QACzC,MAAM,SAAS,GAAG,cAAc,CAAC,GAAG,CAAC,CAAA;QACrC,IAAG,SAAS,KAAK,KAAK,EAAE;YACtB,MAAM,KAAK,GAAG,kBAAkB,CAAC,GAAG,CAAC,CAAA;YACrC,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,IAAI,CAAE;gBACjC,IAAG,SAAS,CAAC,KAAK,EAAE,SAAS,CAAC,MAAM,CAAC,EAAE;oBACrC,OAAO,MAAM,KAAK,SAAS,CAAC,MAAM,CAAA;iBACnC;aACF;SACF,MAAM;YACL,MAAM,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,CAAA;YAC3C,IAAG,WAAW,EAAE;gBACd,OAAO,WAAW,CAAC,WAAW,CAAC,GAAG,EAAE,MAAM,CAAC,CAAA;aAC5C;SACF;QACD,MAAM,IAAI,KAAK,CAAC,CAAA,qCAAA,EAAwC,GAAG,EAAE,CAAC,CAAA;IAChE,CAAC;IAEK,eAAe,CAAC,GAAW,EAAE,IAAgB,EAAE,GAAe,EAAA;;YAClE,MAAM,SAAS,GAAG,cAAc,CAAC,GAAG,CAAC,CAAA;YACrC,IAAG,SAAS,KAAK,KAAK,EAAE;gBACtB,MAAM,KAAK,GAAG,kBAAkB,CAAC,GAAG,CAAC,CAAA;gBACrC,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,IAAI,CAAE;oBACjC,IAAG,SAAS,CAAC,KAAK,EAAE,SAAS,CAAC,MAAM,CAAC,EAAE;wBACrC,OAAO,SAAS,CAAC,eAAe,CAAC,GAAG,EAAE,IAAI,EAAE,GAAG,CAAC,CAAA;qBACjD;iBACF;aACF,MAAM;gBACL,MAAM,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,CAAA;gBAC3C,IAAI,WAAW,EAAE;oBACf,OAAO,WAAW,CAAC,eAAe,CAAC,GAAG,EAAE,IAAI,EAAE,GAAG,CAAC,CAAA;iBACnD;aACF;YACD,MAAM,IAAI,KAAK,CAAC,CAAA,qCAAA,EAAwC,GAAG,EAAE,CAAC,CAAA;QAChE,CAAC;KAAA;CACF;uCAEc,OAAO,CAAA;AAEtB,MAAM,SAAS,GAAG,CAChB,WAAuB,EACvB,MAAkB,EACT,EAAE;IACX,OAAO,WAAW,2KAAC,MAAM,CAAC,MAAM,EAAE,WAAW,CAAC,QAAQ,CAAC,CAAC,EAAE,MAAM,CAAC,UAAU,CAAC,CAAC,CAAA;AAC/E,CAAC,CAAA;AAED,MAAM,iBAAiB,GAAG,WAAW,CAAA;AAErC,0FAA0F;AAC1F,mDAAmD;AACnD,MAAM,kBAAkB,GAAG,CAAC,GAAW,EAAc,EAAE;IACrD,IAAG,CAAC,GAAG,CAAC,UAAU,CAAC,iBAAiB,CAAC,EAAE;QACrC,MAAM,IAAI,KAAK,CAAC,CAAA,sCAAA,EAAyC,GAAG,EAAE,CAAC,CAAA;KAChE;IACD,OAAO,WAAW,2KAAC,UAAU,CAC3B,GAAG,CAAC,KAAK,CAAC,iBAAiB,CAAC,MAAM,CAAC,EACnC,WAAW,CACZ,CAAA;AACH,CAAC,CAAA;AAED,MAAM,cAAc,GAAG,CAAC,GAAW,EAAE,EAAE;IACrC,MAAM,KAAK,GAAG,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,CAAA;IAC5B,IAAG,KAAK,CAAC,CAAC,CAAC,KAAK,KAAK,EAAE;QACrB,MAAM,IAAI,KAAK,CAAC,CAAA,WAAA,EAAc,GAAG,EAAE,CAAC,CAAA;KACrC;IACD,IAAG,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC,EAAE;QACtB,MAAM,IAAI,KAAK,CAAC,CAAA,wBAAA,EAA2B,GAAG,EAAE,CAAC,CAAA;KAClD;IACD,OAAO,KAAK,CAAC,CAAC,CAAC,CAAA;AACjB,CAAC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 2072, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2078, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///Users/alok/Projects/audio-guide/Backend/audioguide-app/node_modules/%40ucans/core/dist/src/index.ts"],"sourcesContent":["import Plugins from \"./plugins.js\"\nimport * as token from \"./token.js\"\nimport * as verifyLib from \"./verify.js\"\nimport * as attenuation from \"./attenuation.js\"\nimport mkBuilderClass from \"./builder.js\"\nimport mkStoreClass from \"./store.js\"\n\nexport * from \"./attenuation.js\"\nexport * from \"./builder.js\"\nexport * from \"./store.js\"\nexport * from \"./token.js\"\nexport * from \"./types.js\"\nexport * from \"./verify.js\"\nexport * from \"./plugins.js\"\nexport * from \"./util.js\"\n\nexport * as capability from \"./capability/index.js\"\nexport * as ability from \"./capability/ability.js\"\n\nexport { ResourcePointer, isResourcePointer } from \"./capability/resource-pointer.js\"\nexport { Ability, isAbility, Superuser, SUPERUSER } from \"./capability/ability.js\"\nexport { Capability, EncodedCapability, isCapability } from \"./capability/index.js\"\n\nexport const getPluginInjectedApi = (plugins: Plugins) => {\n  const build = token.build(plugins)\n  const sign = token.sign(plugins)\n  const signWithKeypair = token.signWithKeypair(plugins)\n  const validate = token.validate(plugins)\n  const validateProofs = token.validateProofs(plugins)\n  const verify = verifyLib.verify(plugins)\n  const delegationChains = attenuation.delegationChains(plugins)\n  const Builder = mkBuilderClass(plugins)\n  const Store = mkStoreClass(plugins)\n\n  return {\n    build,\n    sign,\n    signWithKeypair,\n    validate,\n    validateProofs,\n    verify,\n    delegationChains,\n    Builder,\n    Store\n  }\n}"],"names":[],"mappings":";;;AACA,OAAO,KAAK,KAAK,MAAM,YAAY,CAAA;AACnC,OAAO,KAAK,SAAS,MAAM,aAAa,CAAA;AACxC,OAAO,KAAK,WAAW,MAAM,kBAAkB,CAAA;AAC/C,OAAO,cAAc,MAAM,cAAc,CAAA;AACzC,OAAO,YAAY,MAAM,YAAY,CAAA;;;;;;;;;;;;;;;;;;;AAkB9B,MAAM,oBAAoB,GAAG,CAAC,OAAgB,EAAE,EAAE;IACvD,MAAM,KAAK,GAAG,KAAK,mJAAC,KAAK,CAAC,OAAO,CAAC,CAAA;IAClC,MAAM,IAAI,GAAG,KAAK,mJAAC,IAAI,CAAC,OAAO,CAAC,CAAA;IAChC,MAAM,eAAe,GAAG,KAAK,mJAAC,eAAe,CAAC,OAAO,CAAC,CAAA;IACtD,MAAM,QAAQ,GAAG,KAAK,mJAAC,QAAQ,CAAC,OAAO,CAAC,CAAA;IACxC,MAAM,cAAc,GAAG,KAAK,mJAAC,cAAc,CAAC,OAAO,CAAC,CAAA;IACpD,MAAM,MAAM,GAAG,SAAS,gJAAC,MAAM,CAAC,OAAO,CAAC,CAAA;IACxC,MAAM,gBAAgB,GAAG,WAAW,mJAAC,gBAAgB,CAAC,OAAO,CAAC,CAAA;IAC9D,MAAM,OAAO,iKAAG,UAAA,AAAc,EAAC,OAAO,CAAC,CAAA;IACvC,MAAM,KAAK,+JAAG,UAAA,AAAY,EAAC,OAAO,CAAC,CAAA;IAEnC,OAAO;QACL,KAAK;QACL,IAAI;QACJ,eAAe;QACf,QAAQ;QACR,cAAc;QACd,MAAM;QACN,gBAAgB;QAChB,OAAO;QACP,KAAK;KACN,CAAA;AACH,CAAC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 2126, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}